<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>进程、线程、协程</title>
      <link href="/2018/01/07/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/"/>
      <url>/2018/01/07/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="多任务的概念"><a href="#多任务的概念" class="headerlink" title="多任务的概念"></a>多任务的概念</h1><p>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。<br>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？<br>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。<br>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行</p><h1 id="现实生活中多任务"><a href="#现实生活中多任务" class="headerlink" title="现实生活中多任务"></a>现实生活中多任务</h1><p>现实生活中有很多的场景中的事情是同时进行的，比如开车的时候 手和脚共同来驾驶汽车，再比如唱歌跳舞也是同时进行的；试想，如果把唱歌和跳舞这2件事情分开依次完成的话，估计就没有那么好的效果了（想一下场景：先唱歌，然后在跳舞，O(∩_∩)O哈哈~）<br>程序中。<br>如下程序，来模拟“唱歌跳舞”这件事情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">from time import sleep</span><br><span class="line">def sing():</span><br><span class="line">    for i in range(3):</span><br><span class="line">        print(&quot;正在唱歌...%d&quot;%i)</span><br><span class="line">        sleep(1)</span><br><span class="line">def dance():</span><br><span class="line">    for i in range(3):</span><br><span class="line">        print(&quot;正在跳舞...%d&quot;%i)</span><br><span class="line">        sleep(1)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sing() #唱歌</span><br><span class="line">    dance() #跳舞</span><br></pre></td></tr></table></figure><p>!!!注意<br>    • 很显然刚刚的程序并没有完成唱歌和跳舞同时进行的要求<br>    • 如果想要实现“唱歌跳舞”同时进行，那么就需要一个新的方法，叫做：多线程</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>多线程类似于同时执行多个不同程序，多线程运行有如下优点：<br>• 使用线程可以把占据长时间的程序中的任务放到后台去处理。<br>• 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度<br>• 程序的运行速度可能加快<br>• 在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。<br>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。<br>• 线程可以被抢占（中断）。<br>• 在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） – 这就是线程的退让。<br>线程可以分为:<br>• 内核线程：由操作系统内核创建和撤销。<br>• 用户线程：不需要内核支持而在用户程序中实现的线程。<br>Python3 线程中常用的两个模块为：<br>• <strong>_thread</strong><br>• <strong>threading(推荐使用)</strong><br>thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。<br>开始学习Python线程<br>Python中使用线程有两种方式：函数或者用类来包装线程对象。<br><strong>函数式</strong>：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下:<br><strong>_thread.start_new_thread ( function, args[, kwargs] )</strong><br><strong>参数说明:</strong><br>• <strong>function</strong> - 线程函数。<br>• <strong>args</strong> - 传递给线程函数的参数,他必须是个tuple类型。<br>• <strong>kwargs</strong> - 可选参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">实例：</span><br><span class="line">#!/usr/bin/python3</span><br><span class="line">import _thread</span><br><span class="line">import time</span><br><span class="line"># 为线程定义一个函数</span><br><span class="line">def print_time( threadName, delay):</span><br><span class="line">   count = 0</span><br><span class="line">   while count &lt; 5:</span><br><span class="line">      time.sleep(delay)</span><br><span class="line">      count += 1</span><br><span class="line">      print (&quot;%s: %s&quot; % ( threadName, time.ctime(time.time()) ))</span><br><span class="line"># 创建两个线程</span><br><span class="line">try:</span><br><span class="line">   _thread.start_new_thread( print_time, (&quot;Thread-1&quot;, 2, ) )</span><br><span class="line">   _thread.start_new_thread( print_time, (&quot;Thread-2&quot;, 4, ) )</span><br><span class="line">except:</span><br><span class="line">   print (&quot;Error: 无法启动线程&quot;)</span><br><span class="line">while 1:</span><br><span class="line">   pass</span><br></pre></td></tr></table></figure><p>执行以上程序输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-1: Wed Apr  6 11:36:31 2016</span><br><span class="line">Thread-1: Wed Apr  6 11:36:33 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:36:33 2016</span><br><span class="line">Thread-1: Wed Apr  6 11:36:35 2016</span><br><span class="line">Thread-1: Wed Apr  6 11:36:37 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:36:37 2016</span><br><span class="line">Thread-1: Wed Apr  6 11:36:39 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:36:41 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:36:45 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:36:49 2016</span><br></pre></td></tr></table></figure></p><p>执行以上程后可以按下 ctrl-c to 退出。</p><h2 id="线程模块"><a href="#线程模块" class="headerlink" title="线程模块"></a>线程模块</h2><p>Python3 通过两个标准库 <strong>_thread</strong> 和 <strong>threading</strong> 提供对线程的支持。<br>_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。<br>threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：<br>• <strong>threading.currentThread()</strong>: 返回当前的线程变量。<br>• <strong>threading.enumerate()</strong>: 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。<br>• <strong>threading.activeCount()</strong>: 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。<br>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:<br>• <strong>run()</strong>: 用以表示线程活动的方法。<br>• <strong>start()</strong>:启动线程活动。<br>• <strong>join([time])</strong>: 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。<br>• <strong>isAlive()</strong>: 返回线程是否活动的。<br>• <strong>getName()</strong>: 返回线程名。<br>• <strong>setName()</strong>: 设置线程名。</p><p><strong>使用 threading 模块创建线程</strong><br>我们可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">exitFlag = 0</span><br><span class="line">class myThread (threading.Thread):</span><br><span class="line">    def __init__(self, threadID, name, counter):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.counter = counter</span><br><span class="line">    def run(self):</span><br><span class="line">        print (&quot;开始线程：&quot; + self.name)</span><br><span class="line">        print_time(self.name, self.counter, 5)</span><br><span class="line">        print (&quot;退出线程：&quot; + self.name)</span><br><span class="line">def print_time(threadName, delay, counter):</span><br><span class="line">    while counter:</span><br><span class="line">        if exitFlag:</span><br><span class="line">            threadName.exit()</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= 1</span><br><span class="line"># 创建新线程</span><br><span class="line">thread1 = myThread(1, &quot;Thread-1&quot;, 1)</span><br><span class="line">thread2 = myThread(2, &quot;Thread-2&quot;, 2)</span><br><span class="line"># 开启新线程</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">print (&quot;退出主线程&quot;)</span><br><span class="line">以上程序执行结果如下；</span><br><span class="line">开始线程：Thread-1</span><br><span class="line">开始线程：Thread-2</span><br><span class="line">Thread-1: Wed Apr  6 11:46:46 2016</span><br><span class="line">Thread-1: Wed Apr  6 11:46:47 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:46:47 2016</span><br><span class="line">Thread-1: Wed Apr  6 11:46:48 2016</span><br><span class="line">Thread-1: Wed Apr  6 11:46:49 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:46:49 2016</span><br><span class="line">Thread-1: Wed Apr  6 11:46:50 2016</span><br><span class="line">退出线程：Thread-1</span><br><span class="line">Thread-2: Wed Apr  6 11:46:51 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:46:53 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:46:55 2016</span><br><span class="line">退出线程：Thread-2</span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。<br>使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下：<br>多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。<br>考虑这样一种情况：一个列表里所有元素都是0，线程”set”从后向前把所有元素改成1，而线程”print”负责从前往后读取列表并打印。<br>那么，可能线程”set”开始改的时候，线程”print”便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。<br>锁有两种状态——锁定和未锁定。每当一个线程比如”set”要访问共享数据时，必须先获得锁定；如果已经有别的线程比如”print”获得锁定了，那么就让线程”set”暂停，也就是同步阻塞；等到线程”print”访问完毕，释放锁以后，再让线程”set”继续。<br>经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。<br>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">class myThread (threading.Thread):</span><br><span class="line">    def __init__(self, threadID, name, counter):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.counter = counter</span><br><span class="line">    def run(self):</span><br><span class="line">        print (&quot;开启线程： &quot; + self.name)</span><br><span class="line">        # 获取锁，用于线程同步</span><br><span class="line">        threadLock.acquire()</span><br><span class="line">        print_time(self.name, self.counter, 3)</span><br><span class="line">        # 释放锁，开启下一个线程</span><br><span class="line">        threadLock.release()</span><br><span class="line">def print_time(threadName, delay, counter):</span><br><span class="line">    while counter:</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= 1</span><br><span class="line">threadLock = threading.Lock()</span><br><span class="line">threads = []</span><br><span class="line"># 创建新线程</span><br><span class="line">thread1 = myThread(1, &quot;Thread-1&quot;, 1)</span><br><span class="line">thread2 = myThread(2, &quot;Thread-2&quot;, 2)</span><br><span class="line"># 开启新线程</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"># 添加线程到线程列表</span><br><span class="line">threads.append(thread1)</span><br><span class="line">threads.append(thread2)</span><br><span class="line"># 等待所有线程完成</span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br><span class="line">print (&quot;退出主线程&quot;)</span><br><span class="line">执行以上程序，输出结果为：</span><br><span class="line">开启线程： Thread-1</span><br><span class="line">开启线程： Thread-2</span><br><span class="line">Thread-1: Wed Apr  6 11:52:57 2016</span><br><span class="line">Thread-1: Wed Apr  6 11:52:58 2016</span><br><span class="line">Thread-1: Wed Apr  6 11:52:59 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:53:01 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:53:03 2016</span><br><span class="line">Thread-2: Wed Apr  6 11:53:05 2016</span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><h2 id="线程优先级队列（-Queue）"><a href="#线程优先级队列（-Queue）" class="headerlink" title="线程优先级队列（ Queue）"></a>线程优先级队列（ Queue）</h2><p>Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（<em>先入先出)队列Queue</em>，<em>LIFO（后入先出）队列LifoQueue</em>，和<em>优先级队列 PriorityQueue</em>。<br>这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。<br><strong>Queue 模块中的常用方法:</strong><br>• <strong>Queue.qsize()</strong> 返回队列的大小<br>• <strong>Queue.empty()</strong> 如果队列为空，返回True,反之False<br>• <strong>Queue.full()</strong> 如果队列满了，返回True,反之False<br>• <strong>Queue.full</strong> 与 maxsize 大小对应<br>• <strong>Queue.get([block[, timeout]])</strong>获取队列，timeout等待时间<br>• <strong>Queue.get_nowait()</strong> 相当Queue.get(False)<br>• <strong>Queue.put(item)</strong> 写入队列，timeout等待时间<br>• <strong>Queue.put_nowait(item)</strong> 相当Queue.put(item, False)<br>• <strong>Queue.task_done()</strong> 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号<br>• <strong>Queue.join()</strong> 实际上意味着等到队列为空，再执行别的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">实例:</span><br><span class="line">#!/usr/bin/python3</span><br><span class="line">import queue</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">exitFlag = 0</span><br><span class="line">class myThread (threading.Thread):</span><br><span class="line">    def __init__(self, threadID, name, q):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.q = q</span><br><span class="line">    def run(self):</span><br><span class="line">        print (&quot;开启线程：&quot; + self.name)</span><br><span class="line">        process_data(self.name, self.q)</span><br><span class="line">        print (&quot;退出线程：&quot; + self.name)</span><br><span class="line">def process_data(threadName, q):</span><br><span class="line">    while not exitFlag:</span><br><span class="line">        queueLock.acquire()</span><br><span class="line">        if not workQueue.empty():</span><br><span class="line">            data = q.get()</span><br><span class="line">            queueLock.release()</span><br><span class="line">            print (&quot;%s processing %s&quot; % (threadName, data))</span><br><span class="line">        else:</span><br><span class="line">            queueLock.release()</span><br><span class="line">        time.sleep(1)</span><br><span class="line">threadList = [&quot;Thread-1&quot;, &quot;Thread-2&quot;, &quot;Thread-3&quot;]</span><br><span class="line">nameList = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;]</span><br><span class="line">queueLock = threading.Lock()</span><br><span class="line">workQueue = queue.Queue(10)</span><br><span class="line">threads = []</span><br><span class="line">threadID = 1</span><br><span class="line"># 创建新线程</span><br><span class="line">for tName in threadList:</span><br><span class="line">    thread = myThread(threadID, tName, workQueue)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    threadID += 1</span><br><span class="line"># 填充队列</span><br><span class="line">queueLock.acquire()</span><br><span class="line">for word in nameList:</span><br><span class="line">    workQueue.put(word)</span><br><span class="line">queueLock.release()</span><br><span class="line"># 等待队列清空</span><br><span class="line">while not workQueue.empty():</span><br><span class="line">    pass</span><br><span class="line"># 通知线程是时候退出</span><br><span class="line">exitFlag = 1</span><br><span class="line"># 等待所有线程完成</span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br><span class="line">print (&quot;退出主线程&quot;)</span><br><span class="line">以上程序执行结果：</span><br><span class="line">开启线程：Thread-1</span><br><span class="line">开启线程：Thread-2</span><br><span class="line">开启线程：Thread-3</span><br><span class="line">Thread-3 processing One</span><br><span class="line">Thread-1 processing Two</span><br><span class="line">Thread-2 processing Three</span><br><span class="line">Thread-3 processing Four</span><br><span class="line">Thread-1 processing Five</span><br><span class="line">退出线程：Thread-3</span><br><span class="line">退出线程：Thread-2</span><br><span class="line">退出线程：Thread-1</span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><h2 id="多线程-thread"><a href="#多线程-thread" class="headerlink" title="多线程-thread"></a>多线程-thread</h2><p><1> 实现多任务</1></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import thread</span><br><span class="line">from time import sleep,ctime</span><br><span class="line">def sing():</span><br><span class="line">    for i in range(3):</span><br><span class="line">        print &quot;正在唱歌...%d&quot;%i</span><br><span class="line">        sleep(1)</span><br><span class="line">def dance():</span><br><span class="line">    for i in range(3):</span><br><span class="line">        print &quot;正在跳舞...%d&quot;%i</span><br><span class="line">        sleep(1)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print &apos;---开始---:&apos;, ctime() </span><br><span class="line"># 第一个参数：创建的新线程要执行的代码</span><br><span class="line">    # 第二个参数给新线程执行sing函数时传递的参数，即使没有参数也要传递空元组</span><br><span class="line">    thread.start_new_thread(sing, ()) </span><br><span class="line">    thread.start_new_thread(dance, ())</span><br><span class="line">    sleep(5)</span><br><span class="line">    print &apos;---结束---:&apos;, ctime()</span><br></pre></td></tr></table></figure><p>说明：<br>• 直接调用sing、dance函数，实现的效果是先唱完歌曲之后，在单独进行跳舞<br>• 通过thread.start_new_thread间接调用sing、dance函数，实现了唱歌和跳舞同时进行的完美结合</p><p><2>过程解析<br>单任务：<br><figure class="image-box">                <img src="./img/0.png" alt="" title="" class="">                <p></p>            </figure><br>多任务：<br><figure class="image-box">                <img src="./img/1.png" alt="" title="" class="">                <p></p>            </figure></2></p><h2 id="多线程-threading"><a href="#多线程-threading" class="headerlink" title="多线程-threading"></a>多线程-threading</h2><p>python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用<br><strong><1>使用threading模块</1></strong></p><ol><li>单线程执行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import time</span><br><span class="line">def saySorry():</span><br><span class="line">    print &quot;亲爱的，我错了，我能吃饭了吗？&quot;</span><br><span class="line">    time.sleep(1)</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        saySorry()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">亲爱的，我错了，我能吃饭了吗？</span><br><span class="line">亲爱的，我错了，我能吃饭了吗？</span><br><span class="line">亲爱的，我错了，我能吃饭了吗？</span><br><span class="line">亲爱的，我错了，我能吃饭了吗？</span><br><span class="line">亲爱的，我错了，我能吃饭了吗？</span><br></pre></td></tr></table></figure><ol start="2"><li>多线程执行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">def saySorry():</span><br><span class="line">    print &quot;亲爱的，我错了，我能吃饭了吗？&quot;</span><br><span class="line">    time.sleep(1)</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t = threading.Thread(target=saySorry)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>说明:可以明显看出使用了多线程并发的操作，花费时间要短很多</p><p><strong><2>验证上一小节的第2个问题</2></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import threading</span><br><span class="line">from time import sleep,ctime</span><br><span class="line">def sing():</span><br><span class="line">    for i in range(3):</span><br><span class="line">        print &quot;正在唱歌...%d&quot;%i</span><br><span class="line">        sleep(1)</span><br><span class="line">def dance():</span><br><span class="line">    for i in range(3):</span><br><span class="line">        print &quot;正在跳舞...%d&quot;%i</span><br><span class="line">        sleep(1)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print &apos;---开始---:&apos;, ctime() </span><br><span class="line">t1 = threading.Thread(target=sing)</span><br><span class="line">    t2 = threading.Thread(target=dance)</span><br><span class="line">t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">#sleep(5) # 屏蔽此行代码，试试看，程序是否会立马结束？</span><br><span class="line">    print &apos;---结束---:&apos;, ctime()</span><br></pre></td></tr></table></figure><p><strong><3>线程的执行</3></strong><br> python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。让我们开始第一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        for i in range(3):</span><br><span class="line">            time.sleep(1)</span><br><span class="line">            msg = &quot;I&apos;m &quot;+self.name+&apos; @ &apos;+str(i)</span><br><span class="line">            print msg</span><br><span class="line">def test():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p>执行结果：(运行的结果可能不一样，但是大体是一致的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m Thread-1 @ 0</span><br><span class="line">I&apos;m Thread-2 @ 0</span><br><span class="line">I&apos;m Thread-5 @ 0</span><br><span class="line">I&apos;m Thread-3 @ 0</span><br><span class="line">I&apos;m Thread-4 @ 0</span><br><span class="line">I&apos;m Thread-3 @ 1</span><br><span class="line">I&apos;m Thread-4 @ 1</span><br><span class="line">I&apos;m Thread-5 @ 1</span><br><span class="line">I&apos;m Thread-1 @ 1</span><br><span class="line">I&apos;m Thread-2 @ 1</span><br><span class="line">I&apos;m Thread-4 @ 2</span><br><span class="line">I&apos;m Thread-5 @ 2</span><br><span class="line">I&apos;m Thread-2 @ 2</span><br><span class="line">I&apos;m Thread-1 @ 2</span><br><span class="line">I&apos;m Thread-3 @ 2</span><br></pre></td></tr></table></figure><p>说明:<br>从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。 此外需要注意的是：</p><ol><li>每个线程一定会有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。</li><li>当线程的run()方法结束时该线程完成。</li><li>无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。<br>上面的例子只是简单的演示了创建了线程、主动挂起以及退出线程。下一节，将讨论用互斥锁进行线程同步。<h2 id="线程相关函数"><a href="#线程相关函数" class="headerlink" title="线程相关函数"></a>线程相关函数</h2>. Event<figure class="image-box">                <img src="./img/2.png" alt="" title="" class="">                <p></p>            </figure>. Condition<figure class="image-box">                <img src="./img/3.png" alt="" title="" class="">                <p></p>            </figure>. Semapore<figure class="image-box">                <img src="./img/4.png" alt="" title="" class="">                <p></p>            </figure>. Timer<figure class="image-box">                <img src="./img/5.png" alt="" title="" class="">                <p></p>            </figure>. TLS<figure class="image-box">                <img src="./img/6.png" alt="" title="" class="">                <p></p>            </figure><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1>老手说：“Python下多线程是鸡肋，推荐使用多进程！”，但是为什么这么说呢？<br>要知其然，更要知其所以然。所以有了下面的深入研究：<br>首先强调背景：</li><li><strong>GIL是什么？</strong><br>GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。</li><li><strong>每个CPU在同一时间只能执行一个线程</strong><br>在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。<br>在Python多线程下，每个线程的执行方式：<ol><li>获取GIL</li><li>执行代码直到sleep或者是python虚拟机将其挂起。</li><li>释放GIL<br>可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。<br>在Python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是Python自身的一个计数器，专门作用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。<br>而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。<br>那么是不是python的多线程就完全没用了呢？<br>在这里我们进行分类讨论：</li><li>CPU密集型代码(各种循环处理、计数等等)，在这种情况下，由于计算工作多，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。</li><li>IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。<br>而在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。<br>请注意：多核多线程比单核多线程更差，原因是单核下的多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低。<br>回到最开始的问题：经常我们会听到老手说：“python下想要充分利用多核CPU，就用多进程”，原因是什么呢？<br>原因是：每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。<blockquote><p>所以在这里说结论：多核下，想做并行提升效率，比较通用的方法是使用多进程，能够有效提高执行效率</p></blockquote><h2 id="进程的创建-fork"><a href="#进程的创建-fork" class="headerlink" title="进程的创建-fork"></a>进程的创建-fork</h2></li></ol></li><li><strong>多进程</strong><br>通过前面的学习已经知道了，可以通过多线程完成多任务的要求，其实只要说到多任务，除了线程之外还有一个能够完成多任务的功能：多进程</li><li><strong>fork( )</strong><br>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"># 注意，fork函数，只在Unix/Linux/Mac上运行，windows不可以</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&apos;哈哈1&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;哈哈2&apos;)</span><br></pre></td></tr></table></figure><p>说明：<br>• 程序执行到os.fork()时，操作系统会创建一个新的进程（子进程），然后复制父进程的所有信息到子进程中<br>• 然后父进程和子进程都会从fork()函数中得到一个返回值，其进程中这个值一定是0，而父进程中是子进程的 id号<br>在Unix/Linux操作系统中，提供了一个fork()系统函数，它非常特殊。<br>普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。<br>子进程永远返回0，而父进程返回子进程的ID。<br>这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p><h2 id="多进程修改全局变量"><a href="#多进程修改全局变量" class="headerlink" title="多进程修改全局变量"></a>多进程修改全局变量</h2><p>在学习多线程的时候，提到过，多个线程都是可以访问全局变量的，有时会出现多个线程同时访问，而差生数据错误的情况<br>本小节，来探究一下多进程中，是否也存在这个问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">num = 0</span><br><span class="line"># 注意，fork函数，只在Unix/Linux/Mac上运行，windows不可以</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">    num+=1</span><br><span class="line">    print(&apos;哈哈1---num=%d&apos;%num)</span><br><span class="line">else:</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    num+=1</span><br><span class="line">    print(&apos;哈哈2---num=%d&apos;%num)</span><br></pre></td></tr></table></figure><p>运行结果: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哈哈1---num=1</span><br><span class="line">哈哈2---num=1</span><br></pre></td></tr></table></figure><blockquote><p>总结：<br>    • 多进程中，每个进程中所有数据（包括全局变量）都各有拥有一份，互不影响</p></blockquote><h2 id="多次fork问题"><a href="#多次fork问题" class="headerlink" title="多次fork问题"></a>多次fork问题</h2><p>如果在一个程序，有2次的fork函数调用，是否就会有3个进程呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line"># 注意，fork函数，只在Unix/Linux/Mac上运行，windows不可以</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&apos;哈哈1&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;哈哈2&apos;)</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&apos;哈哈3&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;哈哈4&apos;)</span><br><span class="line">time.sleep(1)</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="./img/7.png" alt="" title="" class="">                <p></p>            </figure><h2 id="获取进程号"><a href="#获取进程号" class="headerlink" title="获取进程号"></a>获取进程号</h2><p>Ubuntu中获取PID<br>操作系统为了更好的有序的管理每个运行的进程，需要对每个进行进行分配一个号码，这个号码成为进程号(PID)<br>在类UNIX系统中，查看当前系统中有哪些进程正常运行，ps -aux</p><p>Python中获取PID的方法<br>获取当前进程的pid的方法为:<strong>getpid()</strong><br>获取父进程的pid的方法为:<strong>getpid()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line"># 注意，fork函数，只在Unix/Linux/Mac上运行，windows不可以</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&apos;哈哈1---pid = %d---ppid = %d----&apos;%(os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">    print(&apos;哈哈2---pid = %d---&apos;%os.getpid())</span><br><span class="line">time.sleep(1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line"># 注意，fork函数，只在Unix/Linux/Mac上运行，windows不可以</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&apos;哈哈1---pid = %d---&apos;%os.getpid())</span><br><span class="line">else:</span><br><span class="line">    print(&apos;哈哈2---pid = %d---&apos;%os.getpid())</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&apos;哈哈3---pid = %d---&apos;%os.getpid())</span><br><span class="line">else:</span><br><span class="line">    print(&apos;哈哈4---pid = %d---&apos;%os.getpid())</span><br><span class="line">time.sleep(1)</span><br></pre></td></tr></table></figure><h2 id="subprocess标准子进程"><a href="#subprocess标准子进程" class="headerlink" title="subprocess标准子进程"></a>subprocess标准子进程</h2><p><strong>subprocess以及常用的封装函数</strong><br>当我们运行python的时候，我们都是在创建并运行一个进程。<br>在Python中，我们通过标准库中的subprocess包来fork一个子进程，并运行一个外部的程序。</p><p>subprocess包中定义有数个创建子进程的函数，这些函数分别以不同的方式创建子进程，所以我们可以根据需要来从中选取一个使用。<br>另外subprocess还提供了一些管理标准流(standard stream)和管道(pipe)的工具，从而在进程间使用文本通信。</p><p>使用subprocess包中的函数创建子进程的时候，要注意:<br>1) 在创建子进程之后，父进程是否暂停，并等待子进程运行。<br>2) 函数返回什么<br>3) 当returncode不为0时，父进程如何处理。</p><p><strong>subprocess.call()</strong><br>父进程等待子进程完成<br>返回退出信息(returncode，相当于exit code）</p><p><strong>subprocess.check_call()</strong><br>父进程等待子进程完成<br>返回0<br>检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，<br>该对象包含有returncode属性，可用try…except…来检查。</p><p><strong>subprocess.check_output()</strong><br>父进程等待子进程完成<br>返回子进程向标准输出的输出结果<br>检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，<br>该对象包含有returncode属性和output属性，output属性为标准输出的输出结果，可用try…except…来检查。<br>这三个函数的使用方法相类似，以subprocess.call()来说明:<br>import subprocess<br>rc = subprocess.call([“ls”,”-l”])<br>将程序名(ls)和所带的参数(-l)一起放在一个表中传递给subprocess.call()<br>可以通过一个shell来解释一整个字符串:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[python] view plain copy</span><br><span class="line">import subprocess  </span><br><span class="line">import subprocess  </span><br><span class="line">child = subprocess.Popen([&quot;ping&quot;,&quot;-c&quot;,&quot;5&quot;,&quot;www.google.com&quot;])  </span><br><span class="line">print(&quot;parent process&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[python] view plain copy</span><br><span class="line">out = subprocess.call(&quot;ls -l&quot;, shell=True)  </span><br><span class="line">out = subprocess.call(&quot;cd ..&quot;, shell=True) </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">使用了shell=True这个参数，这个时候，我们使用一整个字符串，而不是一个表来运行子进程。</span><br><span class="line">Python将先运行一个shell，再用这个shell来解释这整个字符串。</span><br><span class="line">shell命令中有一些是shell的内建命令，这些命令必须通过shell运行，$cd。shell=True允许我们运行这样一些命令。</span><br><span class="line"></span><br><span class="line">__Popen()__</span><br><span class="line">实际上，我们上面的三个函数都是基于Popen()的封装(wrapper)。这些封装的目的在于让我们容易使用子进程。</span><br><span class="line">当我们想要更个性化我们的需求的时候，就要转向Popen类，该类生成的对象用来代表子进程。</span><br><span class="line">与上面的封装不同，Popen对象创建后，主程序不会自动等待子进程完成。</span><br><span class="line">我们必须调用对象的wait()方法，父进程才会等待 (也就是阻塞block)：</span><br><span class="line">从运行结果中看到，父进程在开启子进程之后并没有等待child的完成，而是直接运行print。</span><br><span class="line">对比等待的情况:</span><br></pre></td></tr></table></figure><p>[python] view plain copy<br>import subprocess<br>child = subprocess.Popen([“ping”,”-c”,”5”,”<a href="http://www.google.com&quot;]" target="_blank" rel="noopener">www.google.com&quot;]</a>)<br>child.wait()<br>print(“parent process”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">此外，你还可以在父进程中对子进程进行其它操作，比如我们上面例子中的child对象:</span><br><span class="line">__child.poll()__           # 检查子进程状态</span><br><span class="line">__child.kill()__           # 终止子进程</span><br><span class="line">__child.send_signal()__    # 向子进程发送信号</span><br><span class="line">__child.terminate()__      # 终止子进程</span><br><span class="line"></span><br><span class="line">子进程的PID存储在child.pid</span><br><span class="line">子进程的文本流控制</span><br><span class="line">子进程的标准输入，标准输出和标准错误也可以通过如下属性表示:</span><br><span class="line">child.stdin</span><br><span class="line">child.stdout</span><br><span class="line">child.stderr</span><br><span class="line">我们可以在Popen()建立子进程的时候改变标准输入、标准输出和标准错误，</span><br><span class="line">并可以利用subprocess.PIPE将多个子进程的输入和输出连接在一起，构成管道(pipe):</span><br></pre></td></tr></table></figure></p><p>[python] view plain copy<br>import subprocess<br>child1 = subprocess.Popen([“ls”,”-l”], stdout=subprocess.PIPE)<br>child2 = subprocess.Popen([“wc”], stdin=child1.stdout,stdout=subprocess.PIPE)<br>out = child2.communicate()<br>print(out)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">subprocess.PIPE实际上为文本流提供一个缓存区。</span><br><span class="line">child1的stdout将文本输出到缓存区，随后child2的stdin从该PIPE中将文本读取走。</span><br><span class="line">child2的输出文本也被存放在PIPE中，直到communicate()方法从PIPE中读取出PIPE中的文本。</span><br><span class="line">要注意的是，communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。</span><br><span class="line">我们还可以利用communicate()方法来使用PIPE给子进程输入:</span><br><span class="line">[python] view plain copy</span><br></pre></td></tr></table></figure></p><p>import subprocess<br>child = subprocess.Popen([“cat”], stdin=subprocess.PIPE)<br>child.communicate(“vamei”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我们启动子进程之后，cat会等待输入，直到我们用communicate()输入”vamei”。</span><br><span class="line">通过使用subprocess包，我们可以运行外部程序。这极大的拓展了Python的功能。</span><br><span class="line">如果你已经了解了操作系统的某些应用，你可以从Python中直接调用该应用(而不是完全依赖Python)，并将应用的结果输出给Python，并让Python继续处理。</span><br><span class="line">shell的功能(比如利用文本流连接各个应用)，就可以在Python中实现。</span><br><span class="line">## multiprocessing模块</span><br><span class="line">如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没有fork调用，难道在Windows上无法用Python编写多进程的程序？</span><br><span class="line">由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。</span><br><span class="line">multiprocessing模块提供了一个Process类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</span><br></pre></td></tr></table></figure></p><p>#coding=utf-8<br>from multiprocessing import Process<br>import os</p><h1 id="子进程要执行的代码"><a href="#子进程要执行的代码" class="headerlink" title="子进程要执行的代码"></a>子进程要执行的代码</h1><p>def run_proc(name):<br>    print(‘子进程运行中，name= %s ,pid=%d…’ % (name, os.getpid()))<br>if <strong>name</strong>==’<strong>main</strong>‘:<br>    print(‘父进程 %d.’ % os.getpid())<br>    p = Process(target=run_proc, args=(‘test’,))<br>    print(‘子进程将要执行’)<br>    p.start()<br>    p.join()<br>    print(‘子进程已结束’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果:</span><br></pre></td></tr></table></figure></p><p>父进程 14116.<br>子进程将要执行<br>子进程运行中，name= test ,pid=25456…<br>子进程已结束<br><code>`</code><br>说明<br>    • 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。<br>    • join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>select、poll、epoll的区别</title>
      <link href="/2017/05/09/select%E3%80%81poll%E3%80%81epoll%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/05/09/select%E3%80%81poll%E3%80%81epoll%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="select、poll、epoll之间的区别总结-整理"><a href="#select、poll、epoll之间的区别总结-整理" class="headerlink" title="select、poll、epoll之间的区别总结[整理]"></a><a href="https://chengyuer.github.io/2017/05/09/select、poll、epoll的区别/">select、poll、epoll之间的区别总结[整理]</a></h2><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。关于这三种IO多路复用的用法，前面三篇总结写的很清楚，并用服务器回射echo程序进行了测试。连接如下所示：<br>select：<a href="http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html</a></p><p>poll：<a href="http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html</a></p><p>epoll：<a href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html</a><br>今天对这三种IO多路复用进行对比，参考网上和书上面的资料，整理如下：<br><strong>1、select实现</strong></p><p><strong>select的调用过程如下所示:</strong><br><figure class="image-box">                <img src="./img/1.png" alt="" title="" class="">                <p></p>            </figure><br>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间</p><p>（2）注册回调函数__pollwait</p><p>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</p><p>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</p><p>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</p><p>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</p><p>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</p><p>（8）把fd_set从内核空间拷贝到用户空间。<br><strong>总结：</strong><br><strong>select的几大缺点：</strong></p><p>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p><p>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p><p>（3）select支持的文件描述符数量太小了，默认是1024<br><strong>2 、poll实现</strong></p><p>　　poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。</p><p>关于select和poll的实现分析，可以参考下面几篇博文：<br><a href="http://blog.csdn.net/lizhiguo0532/article/details/6568964#comments" target="_blank" rel="noopener">http://blog.csdn.net/lizhiguo0532/article/details/6568964#comments</a></p><p><a href="http://blog.csdn.net/lizhiguo0532/article/details/6568968" target="_blank" rel="noopener">http://blog.csdn.net/lizhiguo0532/article/details/6568968</a></p><p><a href="http://blog.csdn.net/lizhiguo0532/article/details/6568969" target="_blank" rel="noopener">http://blog.csdn.net/lizhiguo0532/article/details/6568969</a></p><p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-edntwk/index.html?ca=drs-" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/l-cn-edntwk/index.html?ca=drs-</a></p><p><a href="http://linux.chinaunix.net/techdoc/net/2009/05/03/1109887.shtml" target="_blank" rel="noopener">http://linux.chinaunix.net/techdoc/net/2009/05/03/1109887.shtml</a></p><p><strong>3、epoll</strong><br>epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p><p>　　对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p><p>　　对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。</p><p>　　对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。<br><strong>总结：</strong></p><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。<br><strong>参考资料：</strong></p><p><a href="http://www.cnblogs.com/apprentice89/archive/2013/05/09/3070051.html" target="_blank" rel="noopener">http://www.cnblogs.com/apprentice89/archive/2013/05/09/3070051.html</a></p><p><a href="http://www.linuxidc.com/Linux/2012-05/59873p3.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-05/59873p3.htm</a><br><a href="http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/" target="_blank" rel="noopener">http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/</a></p><p><a href="http://blog.csdn.net/kkxgx/article/details/7717125" target="_blank" rel="noopener">http://blog.csdn.net/kkxgx/article/details/7717125</a></p><p><a href="https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/epoll-example.c" target="_blank" rel="noopener">https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/epoll-example.c</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>与Python进阶</title>
      <link href="/2017/03/15/%E4%B8%8EPython%E8%BF%9B%E9%98%B6/"/>
      <url>/2017/03/15/%E4%B8%8EPython%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Pyhton中的函数"><a href="#Pyhton中的函数" class="headerlink" title="Pyhton中的函数"></a>Pyhton中的函数</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>在学习函数之前，一直遵循：面向过程编程，即：根据业务逻辑从上到下实现功能，其往往用一长段代码来实现指定功能，开发过程中最常见的操作就是粘贴复制，也就是将之前实现的代码块复制到现需功能处，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while True：</span><br><span class="line">    if 小明饿了:</span><br><span class="line">       蒸饭</span><br><span class="line">       洗菜</span><br><span class="line">       炒菜</span><br><span class="line">       吃饭</span><br><span class="line">    if 小红饿了:</span><br><span class="line">        蒸饭</span><br><span class="line">        洗菜</span><br><span class="line">        炒菜</span><br><span class="line">        吃饭</span><br><span class="line">    if 小华饿了:</span><br><span class="line">        蒸饭</span><br><span class="line">        洗菜</span><br><span class="line">        炒菜</span><br><span class="line">        吃饭</span><br></pre></td></tr></table></figure><p>定眼一看上述代码，if条件语句下的内容可以被提取出来公用，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def 吃(内容)：</span><br><span class="line">        蒸饭</span><br><span class="line">        洗菜</span><br><span class="line">        炒菜</span><br><span class="line">        吃饭</span><br><span class="line">    </span><br><span class="line">while True：</span><br><span class="line">    </span><br><span class="line">    if 小明饿了:</span><br><span class="line">        吃(&apos;吃饭&apos;)</span><br><span class="line">    </span><br><span class="line">    if 小红饿了:</span><br><span class="line">        吃(&apos;吃饭&apos;)</span><br><span class="line">    </span><br><span class="line">    if 小华饿了:</span><br><span class="line">        吃（&apos;吃饭&apos;）</span><br></pre></td></tr></table></figure><p>对于上述的两种实现方式，第二次必然比第一次的重用性和可读性要好，其实这就是函数式编程和面向过程编程的区别：</p><p>函数式：将某功能代码封装到函数中，日后便无需重复编写，仅调用函数即可<br>面向对象：对函数进行分类和封装，让开发“更快更好更强…”<br>函数式编程最重要的是增强代码的重用性和可读性</p><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>定义一个函数<br>你可以定义一个由自己想要功能的函数，以下是简单的规则：<br>• 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。<br>• 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。<br>• 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。<br>• 函数内容以冒号起始，并且缩进。<br>• return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</p><p><code>语法</code><br>Python 定义函数使用 def 关键字，一般格式如下：<br>def 函数名（参数列表）:<br>    函数体<br>默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。</p><p><code>实例</code><br>让我们使用函数来输出”Hello World！”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def hello() :</span><br><span class="line">   print(&quot;Hello World!&quot;)</span><br><span class="line">&gt;&gt;&gt; hello()</span><br><span class="line">Hello World!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>更复杂点的应用，函数中带上参数变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># 计算面积函数</span><br><span class="line">def area(width, height):</span><br><span class="line">    return width * height</span><br><span class="line"> </span><br><span class="line">def print_welcome(name):</span><br><span class="line">    print(&quot;Welcome&quot;, name)</span><br><span class="line">print_welcome(&quot;Runoob&quot;)</span><br><span class="line">w = 4</span><br><span class="line">h = 5</span><br><span class="line">print(&quot;width =&quot;, w, &quot; height =&quot;, h, &quot; area =&quot;, area(w, h))</span><br><span class="line">以上实例输出结果：</span><br><span class="line">Welcome Runoob</span><br><span class="line">width = 4  height = 5  area = 20</span><br></pre></td></tr></table></figure><h2 id="三、函数调用"><a href="#三、函数调用" class="headerlink" title="三、函数调用"></a>三、函数调用</h2><p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。<br>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。<br>如下实例调用了 printme() 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># 定义函数</span><br><span class="line">def printme( str ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (str);</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line"># 调用函数</span><br><span class="line">printme(&quot;我要调用用户自定义函数!&quot;);</span><br><span class="line">printme(&quot;再次调用同一函数&quot;);</span><br><span class="line">以上实例输出结果：</span><br><span class="line">我要调用用户自定义函数!</span><br><span class="line">再次调用同一函数</span><br></pre></td></tr></table></figure><h2 id="四、参数传递"><a href="#四、参数传递" class="headerlink" title="四、参数传递"></a>四、参数传递</h2><p>在 python 中，类型属于对象，变量是没有类型的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=[1,2,3]</span><br><span class="line">a=&quot;百度&quot;</span><br></pre></td></tr></table></figure><p>以上代码中，[1,2,3] 是 List 类型，”百度” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的<code>引用</code>（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。<br><code>可更改(mutable)与不可更改(immutable)对象</code><br>在 python 中，<strong>strings, tuples, 和 numbers 是不可更改的对象</strong>，而 <strong>list,dict 等则是可以修改的对象</strong>。<br>• 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。<br>• 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</p><p><strong><em>python 函数的参数传递</em></strong>：<br>• 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。<br>• 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响<br>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p><p>python 传不可变对象实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">def ChangeInt( a ):</span><br><span class="line">    a = 10</span><br><span class="line">b = 2</span><br><span class="line">ChangeInt(b)</span><br><span class="line">print( b ) # 结果是 2</span><br></pre></td></tr></table></figure><p>实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。</p><p>传可变对象实例<br>可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">def changeme( mylist ):</span><br><span class="line">   &quot;修改传入的列表&quot;</span><br><span class="line">   mylist.append([1,2,3,4]);</span><br><span class="line">   print (&quot;函数内取值: &quot;, mylist)</span><br><span class="line">   return</span><br><span class="line"> </span><br><span class="line"># 调用changeme函数</span><br><span class="line">mylist = [10,20,30];</span><br><span class="line">changeme( mylist );</span><br><span class="line">print (&quot;函数外取值: &quot;, mylist)</span><br></pre></td></tr></table></figure><p>传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：</p><blockquote><p>函数内取值:  [10, 20, 30, [1, 2, 3, 4]]<br>函数外取值:  [10, 20, 30, [1, 2, 3, 4]]</p></blockquote><h2 id="五、参数"><a href="#五、参数" class="headerlink" title="五、参数"></a>五、参数</h2><p>以下是调用函数时可使用的正式参数类型：<br>• <strong>必需参数</strong><br>• <strong>关键字参数</strong><br>• <strong>默认参数</strong><br>• <strong>不定长参数</strong></p><p><strong>必需参数</strong><br>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。<br>调用printme()函数，你必须传入一个参数，不然会出现语法错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printme( str ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (str);</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line">#调用printme函数</span><br><span class="line">printme();</span><br><span class="line">以上实例输出结果：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 10, in &lt;module&gt;</span><br><span class="line">    printme();</span><br><span class="line">TypeError: printme() missing 1 required positional argument: &apos;str&apos;</span><br></pre></td></tr></table></figure><p><strong>关键字参数</strong><br>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。<br>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。<br>以下实例在函数 printme() 调用时使用参数名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printme( str ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (str);</span><br><span class="line">   return;</span><br><span class="line"></span><br><span class="line">#调用printme函数</span><br><span class="line">printme( str = &quot;百度论坛&quot;);</span><br><span class="line">以上实例输出结果：</span><br><span class="line">百度论坛</span><br></pre></td></tr></table></figure><p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printinfo( name, age ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (&quot;名字: &quot;, name);</span><br><span class="line">   print (&quot;年龄: &quot;, age);</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line">#调用printinfo函数</span><br><span class="line">printinfo( age=50, name=&quot;baidu&quot; );</span><br><span class="line">以上实例输出结果：</span><br><span class="line">名字:  baidu</span><br><span class="line">年龄:  50</span><br></pre></td></tr></table></figure><p><strong>默认参数</strong><br>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printinfo( name, age = 35 ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (&quot;名字: &quot;, name);</span><br><span class="line">   print (&quot;年龄: &quot;, age);</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line">#调用printinfo函数</span><br><span class="line">printinfo( age=50, name=&quot;BAIDU&quot; );</span><br><span class="line">print (&quot;------------------------&quot;)</span><br><span class="line">printinfo( name=&quot;BAIDU&quot; );</span><br><span class="line">以上实例输出结果：</span><br><span class="line">名字:  BAIDU</span><br><span class="line">年龄:  50</span><br><span class="line">------------------------</span><br><span class="line">名字:  BAIDU</span><br><span class="line">年龄:  35</span><br></pre></td></tr></table></figure><p><strong>不定长参数</strong><br>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def functionname([formal_args,] *var_args_tuple ):</span><br><span class="line">   &quot;函数_文档字符串&quot;</span><br><span class="line">   function_suite</span><br><span class="line">   return [expression]</span><br></pre></td></tr></table></figure><p>加了星号（*）的变量名会存放所有未命名的变量参数。如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">def printinfo( arg1, *vartuple ):</span><br><span class="line">   &quot;打印任何传入的参数&quot;</span><br><span class="line">   print (&quot;输出: &quot;)</span><br><span class="line">   print (arg1)</span><br><span class="line">   for var in vartuple:</span><br><span class="line">      print (var)</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line"># 调用printinfo 函数</span><br><span class="line">printinfo( 10 );</span><br><span class="line">printinfo( 70, 60, 50 );</span><br><span class="line">以上实例输出结果：</span><br><span class="line">输出:</span><br><span class="line">10</span><br><span class="line">输出:</span><br><span class="line">70</span><br><span class="line">60</span><br><span class="line">50</span><br></pre></td></tr></table></figure><p><strong>匿名函数</strong><br>python 使用 lambda 来创建匿名函数。<br>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。<br>• lambda 只是一个表达式，函数体比 def 简单很多。<br>• lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。<br>• lambda 函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。<br>• 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。<br><em>语法</em><br>lambda 函数的语法只包含一个语句，如下：<br>lambda [arg1 [,arg2,…..argn]]:expression<br>如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">sum = lambda arg1, arg2: arg1 + arg2;</span><br><span class="line"> </span><br><span class="line"># 调用sum函数</span><br><span class="line">print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))</span><br><span class="line">print (&quot;相加后的值为 : &quot;, sum( 20, 20 ))</span><br><span class="line">以上实例输出结果：</span><br><span class="line">相加后的值为 :  30</span><br><span class="line">相加后的值为 :  40</span><br></pre></td></tr></table></figure><p><em>return语句</em><br>return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># 可写函数说明</span><br><span class="line">def sum( arg1, arg2 ):</span><br><span class="line">   # 返回2个参数的和.&quot;</span><br><span class="line">   total = arg1 + arg2</span><br><span class="line">   print (&quot;函数内 : &quot;, total)</span><br><span class="line">   return total;</span><br><span class="line"># 调用sum函数</span><br><span class="line">total = sum( 10, 20 );</span><br><span class="line">print (&quot;函数外 : &quot;, total)</span><br><span class="line">以上实例输出结果：</span><br><span class="line">函数内 :  30</span><br><span class="line">函数外 :  30</span><br></pre></td></tr></table></figure><p><strong>变量作用域</strong><br>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。<br>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4中，分别是：<br>• L （Local） 局部作用域<br>• E （Enclosing） 闭包函数外的函数中<br>• G （Global） 全局作用域<br>• B （Built-in） 内建作用域<br>以 <code>L –&gt; E –&gt; G –&gt;B</code> 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = int(2.9)  # 内建作用域</span><br><span class="line">g_count = 0  # 全局作用域</span><br><span class="line">def outer():</span><br><span class="line">    o_count = 1  # 闭包函数外的函数中</span><br><span class="line">    def inner():</span><br><span class="line">        i_count = 2  # 局部作用域</span><br></pre></td></tr></table></figure><p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这这些语句内定义的变量，外部也可以访问，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; if True:</span><br><span class="line">...  msg = &apos;I am from GOOGLE&apos;</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; msg</span><br><span class="line">&apos;I am from GOOGLE&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。<br>如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def test():</span><br><span class="line">...     msg_inner = &apos;I am from Runoob&apos;</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; msg_inner</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &apos;msg_inner&apos; is not defined</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p><p><em>全局变量和局部变量</em><br>定义在<code>函数内部的变量</code>拥有一个<code>局部作用域</code>，定义在<code>函数外</code>的拥有<code>全局作用域</code>。<br>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">total = 0; # 这是一个全局变量</span><br><span class="line"># 可写函数说明</span><br><span class="line">def sum( arg1, arg2 ):</span><br><span class="line">    #返回2个参数的和.&quot;</span><br><span class="line">    total = arg1 + arg2; # total在这里是局部变量.</span><br><span class="line">    print (&quot;函数内是局部变量 : &quot;, total)</span><br><span class="line">    return total;</span><br><span class="line">#调用sum函数</span><br><span class="line">sum( 10, 20 );</span><br><span class="line">print (&quot;函数外是全局变量 : &quot;, total)</span><br><span class="line">以上实例输出结果：</span><br><span class="line">函数内是局部变量 :  30</span><br><span class="line">函数外是全局变量 :  0</span><br></pre></td></tr></table></figure><p><em>global 和 nonlocal关键字</em><br>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。<br>以下实例修改全局变量 num：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">num = 1</span><br><span class="line">def fun1():</span><br><span class="line">    global num  # 需要使用 global 关键字声明</span><br><span class="line">    print(num) </span><br><span class="line">    num = 123</span><br><span class="line">    print(num)</span><br><span class="line">fun1()</span><br><span class="line">以上实例输出结果：</span><br><span class="line">1</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">def outer():</span><br><span class="line">    num = 10</span><br><span class="line">    def inner():</span><br><span class="line">        nonlocal num   # nonlocal关键字声明</span><br><span class="line">        num = 100</span><br><span class="line">        print(num)</span><br><span class="line">    inner()</span><br><span class="line">    print(num)</span><br><span class="line">outer()</span><br><span class="line">以上实例输出结果：</span><br><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>另外有一种特殊情况，假设下面这段代码被运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">a = 10</span><br><span class="line">def test():</span><br><span class="line">    a = a + 1</span><br><span class="line">    print(a)</span><br><span class="line">test()</span><br><span class="line">以上程序执行，报错信息如下：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    test()</span><br><span class="line">  File &quot;test.py&quot;, line 5, in test</span><br><span class="line">    a = a + 1</span><br><span class="line">UnboundLocalError: local variable &apos;a&apos; referenced before assignment</span><br></pre></td></tr></table></figure><p>错误信息为局部作用域引用错误，因为函数的内部使用外部作用域的变量时，这个变量是只读的，是不能修改。</p><h1 id="Python中的面向对象"><a href="#Python中的面向对象" class="headerlink" title="Python中的面向对象"></a>Python中的面向对象</h1><h2 id="浅析面向对象编程"><a href="#浅析面向对象编程" class="headerlink" title="浅析面向对象编程"></a>浅析面向对象编程</h2><p>• 面向过程：根据业务逻辑从上到下写垒代码<br>• 函数式：将某功能代码封装到函数中，无需重复编写整个功能代码的实现，仅调用即可<br>• 面向对象：对函数进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程<br>面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程中最常见的操作就是粘贴复制，即：将之前实现的代码块复制到现需功能处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    while True：</span><br><span class="line">        if cpu利用率 &gt; 90%:</span><br><span class="line">            #发送邮件提醒</span><br><span class="line">            连接邮箱服务器</span><br><span class="line">            发送邮件</span><br><span class="line">            关闭连接</span><br><span class="line">if 硬盘使用空间 &gt; 90%:</span><br><span class="line">            #发送邮件提醒</span><br><span class="line">            连接邮箱服务器</span><br><span class="line">            发送邮件</span><br><span class="line">            关闭连接</span><br><span class="line">if 内存占用 &gt; 80%:</span><br><span class="line">            #发送邮件提醒</span><br><span class="line">            连接邮箱服务器</span><br><span class="line">            发送邮件</span><br><span class="line">            关闭连接</span><br><span class="line">随着时间的推移，开始使用了函数式编程，增强代码的重用性和可读性，就变成了这样：</span><br><span class="line">    def 发送邮件(内容)</span><br><span class="line">        #发送邮件提醒</span><br><span class="line">        连接邮箱服务器</span><br><span class="line">        发送邮件</span><br><span class="line">        关闭连接</span><br><span class="line">while True：</span><br><span class="line">if cpu利用率 &gt; 90%:</span><br><span class="line">            发送邮件(&apos;CPU报警&apos;)</span><br><span class="line">if 硬盘使用空间 &gt; 90%:</span><br><span class="line">            发送邮件(&apos;硬盘报警&apos;)</span><br><span class="line">if 内存占用 &gt; 80%:</span><br><span class="line">            发送邮件(&apos;内存报警&apos;)</span><br></pre></td></tr></table></figure><p>今天我们来学习一种新的编程方式：面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）<br>    • 1）解决小明买电脑的故事<br>第一种方式:<br>1)在网上查找资料<br>2)根据自己预算和需求定电脑的型号 MacBook 15 顶配 1W8<br>3)去市场找到苹果店各种店无法甄别真假 随便找了一家<br>4)找到业务员,业务员推荐了另外一款 配置更高价格便宜,也是苹果系统的 1W<br>5)砍价30分钟 付款9999<br>6)成交<br>回去之后发现各种问题<br>第二种方式 :<br>1)找一个靠谱的电脑高手<br>2)给钱交易<br>    • 面向对象和面向过程都是解决问题的一种思路而已<br>    • 买电脑的第一种方式: 强调的是步骤、过程、每一步都是自己亲自去实现的 这种解决问题的思路我们就叫做面向过程<br>    • 买电脑的第二种方式: 强调的是电脑高手, 电脑高手是处理这件事的主角,对我们而言,我们并不必亲自实现整个步骤,只需要调用电脑高手就可以解决问题 这种解决问题的思路就 是面向对象<br>    • 用面向对象的思维解决问题的重点 1)当遇到一个需求的时候不用自己去实现，如果自己一步步实现那就是面向过程 2)应该找一个专门做这个事的人来做 3)面向对象是基于面向过程的<br>    • 2）解决吃啤酒鸭的问题<br>第一种方式（<code>面向过程</code>）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1)养鸭子</span><br><span class="line">2)鸭子长成</span><br><span class="line">3)杀</span><br><span class="line">4)作料</span><br><span class="line">5)烹饪</span><br><span class="line">6)吃</span><br><span class="line">7)卒</span><br></pre></td></tr></table></figure><p>第二种方式（<code>面向对象</code>）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1)找个卖啤酒鸭的人</span><br><span class="line">2)给钱 交易</span><br><span class="line">3)吃</span><br><span class="line">4)胖6斤</span><br></pre></td></tr></table></figure><p>需要了解的定义性文字:<br>面向对象(object-oriented ;简称: OO) 至今还没有统一的概念 我这里把它定义为: 按人们 认识客观世界的系统思维方式,采用基于对象(实体) 的概念建立模型,模拟客观世界分析、设 计、实现软件的办法。<br>面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><strong>类和对象</strong><br>面向对象编程的2个非常重要的概念：类和对象<br>对象是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——类<br>类就相当于制造飞机时的图纸，用它来进行创建的飞机就相当于对象</p><ol><li><em>类</em><br>人以类聚 物以群分。<br>具有相似内部状态和运动规律的实体的集合(或统称、抽象)。<br>具有相同属性和行为事物的统称<br>类是抽象的,在使用的时候通常会找到这个类的一个具体的存在,使用这个具体的存在。一个类可以找到多个对象<figure class="image-box">                <img src="./img/1.png" alt="" title="" class="">                <p></p>            </figure></li><li><em>对象</em><br>某一个具体事物的存在 ,在现实世界中可以是看得见摸得着的。可以是直接使用的<figure class="image-box">                <img src="./img/2.png" alt="" title="" class="">                <p></p>            </figure></li><li><em>类和对象之间的关系</em><figure class="image-box">                <img src="./img/3.png" alt="" title="" class="">                <p></p>            </figure>小总结：类就是创建对象的模板</li><li><em>练习：区分类和对象</em><br>奔驰汽车 类<br>奔驰smart 类<br>张三的那辆奔驰smart 对象<br>狗 类<br>大黄狗 类<br>李四家那只大黄狗 对象<br>水果 类<br>苹果 类<br>红苹果 类 红富士苹果 类<br>我嘴里吃了一半的苹果 对象<br>5.<em>类的构成</em><br>类(Class) 由3个部分构成<br>• <code>类的名称:类名</code><br>• <code>类的属性:一组数据</code><br>• <code>类的方法:允许对进行操作的方法 (行为)</code><br><1> 举例：<br>1）人的类设计,只关心3样东西:<br>• 事物名称(类名):人(Person)<br>• 属性:身高(height)、年龄(age)<br>• 方法(行为/功能):跑(run)、打架(fight)<br>2）狗类的设计<br>• 类名:狗(Dog)<br>• 属性:品种 、毛色、性别、名字、 腿儿的数量<br>方法(行为/功能):叫 、跑、咬人、吃、摇尾巴</1></li></ol><p>6.<em>类的抽象</em><br>如何把日常生活中的事物抽象成程序中的类?<br>拥有相同(或者类似)属性和行为的对象都可以抽像出一个类<br>方法:一般名词都是类(名词提炼法)</p><p><1> 坦克发射3颗炮弹轰掉了2架飞机<br>• 坦克–》可以抽象成 类<br>• 炮弹–》可以抽象成类<br>• 飞机-》可以抽象成类</1></p><p><2> 小明在公车上牵着一条叼着热狗的狗<br>• 小明–》 人类<br>• 公车–》 交通工具类<br>• 热狗–》 食物类<br>• 狗–》 狗类</2></p><p><3>【想一想】如下图中，有哪些类呢？<br><figure class="image-box">                <img src="./img/4.png" alt="" title="" class="">                <p></p>            </figure><br>说明：<br>• 人<br>• 枪<br>• 子弹<br>• 手榴弹<br>• 刀子<br>• 箱子</3></p><h2 id="Python面向对象"><a href="#Python面向对象" class="headerlink" title="Python面向对象"></a>Python面向对象</h2><p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。<br>如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。<br>接下来我们先来简单的了解下面向对象的一些基本特征。</p><p><strong>面向对象技术简介</strong><br>• <code>类(Class):</code> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。<br>• <code>类变量：</code>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。<br>• <code>数据成员：</code>类变量或者实例变量用于处理类及其实例对象的相关的数据。<br>• <code>方法重写：</code>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。<br>• <code>实例变量：</code>定义在方法中的变量，只作用于当前实例的类。<br>• <code>继承：</code>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。<br>• <code>实例化：</code>创建一个类的实例，类的具体对象。<br>• <code>方法：</code>类中定义的函数。<br>• <code>对象：</code>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。<br>和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。<br>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。<br>对象可以包含任意数量和类型的数据。<br><em>类定义</em><br>语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ClassName:</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。<br>类对象<br>类对象支持两种操作：<code>属性引用和实例化</code>。<br>属性引用使用和 Python 中所有的属性引用一样的标准语法：<code>obj.name</code>。<br>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">class MyClass:</span><br><span class="line">    &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span><br><span class="line">    i = 12345</span><br><span class="line">    def f(self):</span><br><span class="line">        return &apos;hello world&apos;</span><br><span class="line"># 实例化类</span><br><span class="line">x = MyClass()</span><br><span class="line"># 访问类的属性和方法</span><br><span class="line">print(&quot;MyClass 类的属性 i 为：&quot;, x.i)</span><br><span class="line">print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f())</span><br><span class="line">实例化类：</span><br><span class="line"># 实例化类</span><br><span class="line">x = MyClass()</span><br><span class="line"># 访问类的属性和方法</span><br><span class="line">以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">MyClass 类的属性 i 为： 12345</span><br><span class="line">MyClass 类的方法 f 输出为： hello world</span><br></pre></td></tr></table></figure><p>很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为 <code>__init__()</code>的特殊方法（构造方法），像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    self.data = []</span><br><span class="line">类定义了 __init__() 方法的话，类的实例化操作会自动调用 __init__() 方法。所以在下例中，可以这样创建一个新的实例:</span><br><span class="line">x = MyClass()</span><br><span class="line">当然， __init__() 方法可以有参数，参数通过 __init__() 传递到类的实例化操作上。例如:</span><br><span class="line">&gt;&gt;&gt; class Complex:</span><br><span class="line">...     def __init__(self, realpart, imagpart):</span><br><span class="line">...         self.r = realpart</span><br><span class="line">...         self.i = imagpart</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; x = Complex(3.0, -4.5)</span><br><span class="line">&gt;&gt;&gt; x.r, x.i</span><br><span class="line">(3.0, -4.5)</span><br></pre></td></tr></table></figure><p>self代表类的实例，而非类<br>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">    def prt(self):</span><br><span class="line">        print(self)</span><br><span class="line">        print(self.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line">以上实例执行结果为：</span><br><span class="line">&lt;__main__.Test instance at 0x100771878&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure><p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。<br>self 不是 python 关键字，我们把他换成 baidu 也是可以正常执行的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">    def prt(baidu):</span><br><span class="line">        print(baidu)</span><br><span class="line">        print(baidu.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line">以上实例执行结果为：</span><br><span class="line">&lt;__main__.Test instance at 0x100771878&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure><p><em>类的方法</em><br>在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">#类定义</span><br><span class="line">class people:</span><br><span class="line">    #定义基本属性</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    #定义私有属性,私有属性在类外部无法直接进行访问</span><br><span class="line">    __weight = 0</span><br><span class="line">    #定义构造方法</span><br><span class="line">    def __init__(self,n,a,w):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))</span><br><span class="line"># 实例化类</span><br><span class="line">p = people(&apos;baidu&apos;,10,30)</span><br><span class="line">p.speak()</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">baidu 说: 我 10 岁。</span><br></pre></td></tr></table></figure><p><em>继承</em><br>Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DerivedClassName(BaseClassName1):</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法。<br>BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:<br>class DerivedClassName(modname.BaseClassName):<br>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">#类定义</span><br><span class="line">class people:</span><br><span class="line">    #定义基本属性</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    #定义私有属性,私有属性在类外部无法直接进行访问</span><br><span class="line">    __weight = 0</span><br><span class="line">    #定义构造方法</span><br><span class="line">    def __init__(self,n,a,w):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))</span><br><span class="line">#单继承示例</span><br><span class="line">class student(people):</span><br><span class="line">    grade = &apos;&apos;</span><br><span class="line">    def __init__(self,n,a,w,g):</span><br><span class="line">        #调用父类的构函</span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    #覆写父类的方法</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))</span><br><span class="line">s = student(&apos;ken&apos;,10,60,3)</span><br><span class="line">s.speak()</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">ken 说: 我 10 岁了，我在读 3 年级</span><br></pre></td></tr></table></figure><p><em>多继承</em><br>Python同样有限的支持多继承形式。多继承的类定义形如下例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DerivedClassName(Base1, Base2, Base3):</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">#类定义</span><br><span class="line">class people:</span><br><span class="line">    #定义基本属性</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    #定义私有属性,私有属性在类外部无法直接进行访问</span><br><span class="line">    __weight = 0</span><br><span class="line">    #定义构造方法</span><br><span class="line">    def __init__(self,n,a,w):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))</span><br><span class="line">#单继承示例</span><br><span class="line">class student(people):</span><br><span class="line">    grade = &apos;&apos;</span><br><span class="line">    def __init__(self,n,a,w,g):</span><br><span class="line">        #调用父类的构函</span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    #覆写父类的方法</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))</span><br><span class="line">#另一个类，多重继承之前的准备</span><br><span class="line">class speaker():</span><br><span class="line">    topic = &apos;&apos;</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    def __init__(self,n,t):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))</span><br><span class="line">#多重继承</span><br><span class="line">class sample(speaker,student):</span><br><span class="line">    a =&apos;&apos;</span><br><span class="line">    def __init__(self,n,a,w,g,t):</span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line">test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)</span><br><span class="line">test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">我叫 Tim，我是一个演说家，我演讲的主题是 Python</span><br></pre></td></tr></table></figure><p><em>方法重写</em><br>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">class Parent:        # 定义父类</span><br><span class="line">   def myMethod(self):</span><br><span class="line">      print (&apos;调用父类方法&apos;)</span><br><span class="line">class Child(Parent): # 定义子类</span><br><span class="line">   def myMethod(self):</span><br><span class="line">      print (&apos;调用子类方法&apos;)</span><br><span class="line">c = Child()          # 子类实例</span><br><span class="line">c.myMethod()         # 子类调用重写方法</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">调用子类方法</span><br></pre></td></tr></table></figure><p><em>类属性与方法</em></p><ol><li><code>类的私有属性</code><blockquote><p><strong>private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.</strong>private_attrs。</p></blockquote></li><li><code>类的方法</code><blockquote><p>在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数</p></blockquote></li><li><code>类的私有方法</code><blockquote><p><strong>private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.</strong>private_methods。<br>实例<br>类的私有属性实例如下：</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">class JustCounter:</span><br><span class="line">    __secretCount = 0  # 私有变量</span><br><span class="line">    publicCount = 0    # 公开变量</span><br><span class="line">def count(self):</span><br><span class="line">        self.__secretCount += 1</span><br><span class="line">        self.publicCount += 1</span><br><span class="line">        print (self.__secretCount)</span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line">print (counter.publicCount)</span><br><span class="line">print (counter.__secretCount)  # 报错，实例不能访问私有变量</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 16, in &lt;module&gt;</span><br><span class="line">    print (counter.__secretCount)  # 报错，实例不能访问私有变量</span><br><span class="line">AttributeError: &apos;JustCounter&apos; object has no attribute &apos;__secretCount&apos;</span><br><span class="line">类的私有方法实例如下：</span><br><span class="line">#!/usr/bin/python3</span><br><span class="line">class Site:</span><br><span class="line">def __init__(self, name, url):</span><br><span class="line">self.name = name       # public</span><br><span class="line">self.__url = url   # private</span><br><span class="line">def who(self):</span><br><span class="line">print(&apos;name  : &apos;, self.name)</span><br><span class="line">print(&apos;url : &apos;, self.__url)</span><br><span class="line">def __foo(self):          # 私有方法</span><br><span class="line">print(&apos;这是私有方法&apos;)</span><br><span class="line">def foo(self):            # 公共方法</span><br><span class="line">print(&apos;这是公共方法&apos;)</span><br><span class="line">self.__foo()</span><br><span class="line">x = Site(&apos;百度&apos;, &apos;www.baidu.com&apos;)</span><br><span class="line">x.who()        # 正常输出</span><br><span class="line">x.foo()        # 正常输出</span><br><span class="line">x.__foo()      # 报错</span><br><span class="line">以上实例执行结果：</span><br></pre></td></tr></table></figure><ol start="4"><li><code>类的专有方法：</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__init__ : 构造函数，在生成对象时调用</span><br><span class="line">__del__ : 析构函数，释放对象时使用</span><br><span class="line">__repr__ : 打印，转换</span><br><span class="line">__setitem__ : 按照索引赋值</span><br><span class="line">__getitem__: 按照索引获取值</span><br><span class="line">__len__: 获得长度</span><br><span class="line">__cmp__: 比较运算</span><br><span class="line">__call__: 函数调用</span><br><span class="line">__add__: 加运算</span><br><span class="line">__sub__: 减运算</span><br><span class="line">__mul__: 乘运算</span><br><span class="line">__div__: 除运算</span><br><span class="line">__mod__: 求余运算</span><br><span class="line">__pow__: 平方</span><br></pre></td></tr></table></figure><ol start="5"><li><code>运算符重载</code><br>Python同样支持运算符重载，我么可以对类的专有方法进行重载，实例如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">class Vector:</span><br><span class="line">   def __init__(self, a, b):</span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line">def __str__(self):</span><br><span class="line">      return &apos;Vector (%d, %d)&apos; % (self.a, self.b)</span><br><span class="line">   </span><br><span class="line">   def __add__(self,other):</span><br><span class="line">      return Vector(self.a + other.a, self.b + other.b)</span><br><span class="line">v1 = Vector(2,10)</span><br><span class="line">v2 = Vector(5,-2)</span><br><span class="line">print (v1 + v2)</span><br><span class="line">以上代码执行结果如下所示:</span><br><span class="line">Vector(7,8)</span><br></pre></td></tr></table></figure><h2 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h2><p><strong>静态方法和类方法</strong></p><ol><li><code>类方法</code><br>是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了），能够通过实例对象和类对象去访问。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class people:</span><br><span class="line">    country = &apos;china&apos;</span><br><span class="line">#类方法，用classmethod来进行修饰</span><br><span class="line">    @classmethod</span><br><span class="line">    def getCountry(cls):</span><br><span class="line">        return cls.country</span><br><span class="line">p = people()</span><br><span class="line">print p.getCountry()    #可以用过实例对象引用</span><br><span class="line">print people.getCountry()    #可以通过类对象引用</span><br><span class="line">类方法还有一个用途就是可以对类属性进行修改：</span><br><span class="line">class people:</span><br><span class="line">    country = &apos;china&apos;</span><br><span class="line">#类方法，用classmethod来进行修饰</span><br><span class="line">    @classmethod</span><br><span class="line">    def getCountry(cls):</span><br><span class="line">        return cls.country</span><br><span class="line">@classmethod</span><br><span class="line">    def setCountry(cls,country):</span><br><span class="line">        cls.country = country</span><br><span class="line">p = people()</span><br><span class="line">print p.getCountry()    #可以用过实例对象引用</span><br><span class="line">print people.getCountry()    #可以通过类对象引用</span><br><span class="line">p.setCountry(&apos;japan&apos;)   </span><br><span class="line">print p.getCountry()   </span><br><span class="line">print people.getCountry()</span><br></pre></td></tr></table></figure><p>结果显示在用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变<br>2.<code>静态方法</code><br>需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class people:</span><br><span class="line">    country = &apos;china&apos;</span><br><span class="line">@staticmethod</span><br><span class="line">    #静态方法</span><br><span class="line">    def getCountry():</span><br><span class="line">        return people.country</span><br><span class="line">print people.getCountry()</span><br></pre></td></tr></table></figure><p><em>总结</em><br>从类方法和实例方法以及静态方法的定义形式就可以看出来，<strong>类方法的第一个参数是类对象cls</strong>，那么通过cls引用的必定是类对象的属性和方法；而<strong>实例方法的第一个参数是实例对象self</strong>，那么通过self引用的可能是类属性、也有可能是实例属性（这个需要具体分析），不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。静态方法中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类对象来引用。</p><h2 id="Python内置类属性"><a href="#Python内置类属性" class="headerlink" title="Python内置类属性"></a>Python内置类属性</h2><p><em>Python内置类属性</em><br><code>__dict__</code> : 类的属性（包含一个字典，由类的数据属性组成）<br><code>__doc__</code> :类的文档字符串<br><code>__name__</code>: 类名<br><code>__module__</code>: 类定义所在的模块（类的全名是<code>__main__.className</code>，如果类位于一个导入模块mymod中，那么<code>className.__module__</code>等于 mymod）<br><code>__bases__</code> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</p><h2 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h2><p>python类的体系中如果出现了继承,子类如果没有写自己的初始化方法,会自动继承第一个父类的方法,所以我们需要自己写子类的初始化:如果像下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Enter A&quot;)</span><br><span class="line">        print(&quot;Leave A&quot;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Enter B&quot;)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        print(&quot;Leave B&quot;)</span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Enter C&quot;)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        print(&quot;Leave C&quot;)</span><br><span class="line"></span><br><span class="line">class D(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Enter D&quot;)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        print(&quot;Leave D&quot;)</span><br><span class="line"></span><br><span class="line">class E(B, C, D):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Enter E&quot;)</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        C.__init__(self)</span><br><span class="line">        D.__init__(self)</span><br><span class="line">        print(&quot;Leave E&quot;)</span><br><span class="line">s=E()</span><br></pre></td></tr></table></figure><p>会造成公共父类A被调用多次.</p><p>正确的办法是使用super,它会把当前的类返回一个父类的对象,注意你在体系中使用了super那么所有的地方都要使用super,否则可能造成父类多次被调用或者不能调用所有的父类方法(这是由super的机制造成的,具体实现不懂),super保证所有父类只会执行一次，而且修改代码时也很方便:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class A(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;Enter A&apos;)</span><br><span class="line">        self.__test = 0</span><br><span class="line">class C(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;Enter C&apos;)</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.__test2 = 3</span><br><span class="line">class D(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(&apos;enter D&apos;)</span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;Enter B&apos;)</span><br><span class="line">        super().__init__()</span><br><span class="line">    def set(self):</span><br><span class="line">        self.__test = 2</span><br><span class="line">    def display(self):</span><br><span class="line">        print(dir(self))</span><br><span class="line">class E(C,D):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;Enter E&apos;)</span><br><span class="line">        super().__init__();</span><br></pre></td></tr></table></figure><h2 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a>isinstance</h2><p><em>语法：</em><br>isinstance（object，type）</p><p>作用：来判断一个对象是否是一个已知的类型。<br>其第一个参数（object）为对象，第二个参数（type）为类型名(int…)或类型名的一个列表((int,list,float)是一个列表)。其返回值为布尔型（True or flase）。<br>若对象的类型与参数二的类型相同则返回True。若参数二为一个元组，则若对象类型与元组中类型名之一相同即返回True。<br>下面是两个例子：<br>例一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 4</span><br><span class="line">&gt;&gt;&gt; isinstance (a,int)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance (a,str)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance (a,(str,int,list))</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>例二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &quot;b&quot;</span><br><span class="line">&gt;&gt;&gt; isinstance(a,str)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(a,int)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(a,(int,list,float))</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(a,(int,list,float,str))</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p><strong>一、isinstance()</strong><br>在Python中可以使用type()与isinstance()这两个函数判断对象类型，而isinstance()函数的使用上比type更加方便。<br>复制代码 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line"> </span><br><span class="line">a = 10</span><br><span class="line"> </span><br><span class="line">def b():</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">print isinstance(a,(int,str))</span><br><span class="line">print isinstance(a,(float,str))</span><br><span class="line">print isinstance(b,(str,int))</span><br><span class="line"> </span><br><span class="line">class c:</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">obj = c()</span><br><span class="line"> </span><br><span class="line">print isinstance(obj,(c,int))</span><br></pre></td></tr></table></figure><p>执行结果：<br>复制代码 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line"> False</span><br><span class="line"> False</span><br><span class="line"> True</span><br></pre></td></tr></table></figure><p> <strong>二、isinstance 和 type的区别</strong><br><em>isinstance 和 type的区别在于：</em><br>复制代码 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">     pass</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">     pass</span><br><span class="line"></span><br><span class="line">isinstance(A(), A)  # returns True</span><br><span class="line"> type(A()) == A      # returns True</span><br><span class="line"> isinstance(B(), A)    # returns True</span><br><span class="line"> type(B()) == A        # returns False</span><br></pre></td></tr></table></figure><p>区别就是 对于subclass之类的 type就不行了，所以,强烈建议不要使用type判断对象类型。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型”。<br>所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态<br><strong>Python伪代码实现Java或C#的多态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  class F1:</span><br><span class="line">      pass</span><br><span class="line"></span><br><span class="line">class S1(F1):</span><br><span class="line">      def show(self):</span><br><span class="line">          print &apos;S1.show&apos;</span><br><span class="line"></span><br><span class="line">class S2(F1):</span><br><span class="line">      def show(self):</span><br><span class="line">          print &apos;S2.show&apos;</span><br></pre></td></tr></table></figure><p>由于在Java或C#中定义函数参数时，必须指定参数的类型<br>为了让Func函数既可以执行S1对象的show方法，又可以执行S2对象的show方法，所以，定义了一个S1和S2类的父类<br>而实际传入的参数是：S1对象和S2对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def Func(F1 obj):</span><br><span class="line">      &quot;&quot;&quot;Func函数需要接收一个F1类型或者F1子类的类型&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">print obj.show()</span><br><span class="line"></span><br><span class="line">s1_obj = S1()</span><br><span class="line">  Func(s1_obj) # 在Func函数中传入S1类的对象 s1_obj，执行 S1 的show方法，结果：S1.show</span><br><span class="line"></span><br><span class="line">s2_obj = S2()</span><br><span class="line">  Func(s2_obj) # 在Func函数中传入Ss类的对象 ss_obj，执行 Ss 的show方法，结果：S2.show</span><br></pre></td></tr></table></figure><p><strong>Python “鸭子类型”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  class F1:</span><br><span class="line">      pass</span><br><span class="line"></span><br><span class="line">class S1(F1):</span><br><span class="line"></span><br><span class="line">def show(self):</span><br><span class="line">          print &apos;S1.show&apos;</span><br><span class="line"></span><br><span class="line">class S2(F1):</span><br><span class="line"></span><br><span class="line">def show(self):</span><br><span class="line">          print &apos;S2.show&apos;</span><br><span class="line"></span><br><span class="line">def Func(obj):</span><br><span class="line">      print obj.show()</span><br><span class="line"></span><br><span class="line">s1_obj = S1()</span><br><span class="line">  Func(s1_obj) </span><br><span class="line"></span><br><span class="line">s2_obj = S2()</span><br><span class="line">  Func(s2_obj)</span><br></pre></td></tr></table></figure><h1 id="File-文件-方法"><a href="#File-文件-方法" class="headerlink" title="File(文件) 方法"></a>File(文件) 方法</h1><p>file 对象使用 open 函数来创建：<br><strong>open函数</strong>，该函数用于文件处理:<br>操作文件时，一般需要经历如下步骤：<br>打开文件<br>操作文件<br><strong>一、打开文件</strong><br><code>文件句柄 = open(&#39;文件路径&#39;, &#39;模式&#39;)</code><br>打开文件时，需要指定文件路径和以何等方式打开文件，打开后，即可获取该文件句柄，日后通过此文件句柄对该文件操作。<br>打开文件的模式有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">r ，只读模式【默认】</span><br><span class="line">w，只写模式【不可读；不存在则创建；存在则清空内容；】</span><br><span class="line">x， 只写模式【不可读；不存在则创建，存在则报错】</span><br><span class="line">a， 追加模式【可读；   不存在则创建；存在则只追加内容；】</span><br><span class="line">&quot;+&quot; 表示可以同时读写某个文件</span><br><span class="line">r+， 读写【可读，可写】</span><br><span class="line">w+，写读【可读，可写】</span><br><span class="line">x+ ，写读【可读，可写】</span><br><span class="line">a+， 写读【可读，可写】</span><br><span class="line">&quot;b&quot;表示以字节的方式操作</span><br><span class="line">rb  或 r+b</span><br><span class="line">wb 或 w+b</span><br><span class="line">xb 或 w+b</span><br><span class="line">ab 或 a+b</span><br></pre></td></tr></table></figure><p> 注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型<br><strong>二、操作文件</strong><br>下表列出了 file 对象常用的函数：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">file.close()关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">file.flush()刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">file.fileno()返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">file.isatty()如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">file.next()返回文件下一行。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">file.read([size])从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">file.readline([size])读取整行，包括 “\n” 字符。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">file.readlines([sizeint])读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">file.seek(offset[, whence])设置文件当前位置</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">file.tell()返回文件当前位置。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">file.truncate([size])截取文件，截取的字节通过size指定，默认为当前文件位置。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">file.write(str)将字符串写入文件，没有返回值。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">file.writelines(sequence)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr></tbody></table><p><strong>三、管理上下文</strong><br>为了避免打开文件后忘记关闭，可以通过管理上下文，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;log&apos;,&apos;r&apos;) as f:</span><br><span class="line">        </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如此方式，当with代码块执行完毕时，内部会自动关闭并释放文件资源。</p><p>在Python 2.7 及以后，with又支持同时对多个文件的上下文进行管理，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;log1&apos;) as obj1, open(&apos;log2&apos;) as obj2:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h1 id="OS文件-目录方法"><a href="#OS文件-目录方法" class="headerlink" title="OS文件/目录方法"></a>OS文件/目录方法</h1><p>os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">os.access(path, mode)检验权限模式</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">os.chdir(path)改变当前工作目录</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">os.chflags(path, flags)设置路径的标记为数字标记。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">os.chmod(path, mode)更改权限</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">os.chown(path, uid, gid)更改文件所有者</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">os.chroot(path)改变当前进程的根目录</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">os.close(fd)关闭文件描述符 fd</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">os.closerange(fd_low, fd_high)关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">os.dup(fd)复制文件描述符 fd</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">os.dup2(fd, fd2)将一个文件描述符 fd 复制到另一个 fd2</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">os.fchdir(fd)通过文件描述符改变当前工作目录</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">os.fchmod(fd, mode)改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">os.fchown(fd, uid, gid)修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">os.fdatasync(fd)强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">os.fdopen(fd[, mode[, bufsize]])通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left">os.fpathconf(fd, name)返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left">os.fstat(fd)返回文件描述符fd的状态，像stat()。</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left">os.fstatvfs(fd)返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()</td></tr><tr><td style="text-align:left">19</td><td style="text-align:left">os.fsync(fd)强制将文件描述符为fd的文件写入硬盘。</td></tr><tr><td style="text-align:left">20</td><td style="text-align:left">os.ftruncate(fd, length)裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td></tr><tr><td style="text-align:left">21</td><td style="text-align:left">os.getcwd()返回当前工作目录</td></tr><tr><td style="text-align:left">22</td><td style="text-align:left">os.getcwdu()返回一个当前工作目录的Unicode对象</td></tr><tr><td style="text-align:left">23</td><td style="text-align:left">os.isatty(fd)如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td></tr><tr><td style="text-align:left">24</td><td style="text-align:left">os.lchflags(path, flags)设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td></tr><tr><td style="text-align:left">25</td><td style="text-align:left">os.lchmod(path, mode)修改连接文件权限</td></tr><tr><td style="text-align:left">26</td><td style="text-align:left">os.lchown(path, uid, gid)更改文件所有者，类似 chown，但是不追踪链接。</td></tr><tr><td style="text-align:left">27</td><td style="text-align:left">os.link(src, dst)创建硬链接，名为参数 dst，指向参数 src</td></tr><tr><td style="text-align:left">28</td><td style="text-align:left">os.listdir(path)返回path指定的文件夹包含的文件或文件夹的名字的列表。</td></tr><tr><td style="text-align:left">29</td><td style="text-align:left">os.lseek(fd, pos, how)设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td></tr><tr><td style="text-align:left">30</td><td style="text-align:left">os.lstat(path)像stat(),但是没有软链接</td></tr><tr><td style="text-align:left">31</td><td style="text-align:left">os.major(device)从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td></tr><tr><td style="text-align:left">32</td><td style="text-align:left">os.makedev(major, minor)以major和minor设备号组成一个原始设备号</td></tr><tr><td style="text-align:left">33</td><td style="text-align:left">os.makedirs(path[, mode])递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td></tr><tr><td style="text-align:left">34</td><td style="text-align:left">os.minor(device)从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td></tr><tr><td style="text-align:left">35</td><td style="text-align:left">os.mkdir(path[, mode])以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td></tr><tr><td style="text-align:left">36</td><td style="text-align:left">os.mkfifo(path[, mode])创建命名管道，mode 为数字，默认为 0666 (八进制)</td></tr><tr><td style="text-align:left">37</td><td style="text-align:left">os.mknod(filename[, mode=0600, device])创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td></tr><tr><td style="text-align:left">38</td><td style="text-align:left">os.open(file, flags[, mode])打开一个文件，并且设置需要的打开选项，mode参数是可选的</td></tr><tr><td style="text-align:left">39</td><td style="text-align:left">os.openpty()打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td></tr><tr><td style="text-align:left">40</td><td style="text-align:left">os.pathconf(path, name)返回相关文件的系统配置信息。</td></tr><tr><td style="text-align:left">41</td><td style="text-align:left">os.pipe()创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td></tr><tr><td style="text-align:left">42</td><td style="text-align:left">os.popen(command[, mode[, bufsize]])从一个 command 打开一个管道</td></tr><tr><td style="text-align:left">43</td><td style="text-align:left">os.read(fd, n)从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td></tr><tr><td style="text-align:left">44</td><td style="text-align:left">os.readlink(path)返回软链接所指向的文件</td></tr><tr><td style="text-align:left">45</td><td style="text-align:left">os.remove(path)删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td></tr><tr><td style="text-align:left">46</td><td style="text-align:left">os.removedirs(path)递归删除目录。</td></tr><tr><td style="text-align:left">47</td><td style="text-align:left">os.rename(src, dst)重命名文件或目录，从 src 到 dst</td></tr><tr><td style="text-align:left">48</td><td style="text-align:left">os.renames(old, new)递归地对目录进行更名，也可以对文件进行更名。</td></tr><tr><td style="text-align:left">49</td><td style="text-align:left">os.rmdir(path)删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td></tr><tr><td style="text-align:left">50</td><td style="text-align:left">os.stat(path)获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td></tr><tr><td style="text-align:left">51</td><td style="text-align:left">os.stat_float_times([newvalue])决定stat_result是否以float对象显示时间戳</td></tr><tr><td style="text-align:left">52</td><td style="text-align:left">os.statvfs(path)获取指定路径的文件系统统计信息</td></tr><tr><td style="text-align:left">53</td><td style="text-align:left">os.symlink(src, dst)创建一个软链接</td></tr><tr><td style="text-align:left">54</td><td style="text-align:left">os.tcgetpgrp(fd)返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td></tr><tr><td style="text-align:left">55</td><td style="text-align:left">os.tcsetpgrp(fd, pg)设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td></tr><tr><td style="text-align:left">56</td><td style="text-align:left">os.tempnam([dir[, prefix]])返回唯一的路径名用于创建临时文件。</td></tr><tr><td style="text-align:left">57</td><td style="text-align:left">os.tmpfile()返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td></tr><tr><td style="text-align:left">58</td><td style="text-align:left">os.tmpnam()为创建一个临时文件返回一个唯一的路径</td></tr><tr><td style="text-align:left">59</td><td style="text-align:left">os.ttyname(fd)返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td></tr><tr><td style="text-align:left">60</td><td style="text-align:left">os.unlink(path)删除文件路径</td></tr><tr><td style="text-align:left">61</td><td style="text-align:left">os.utime(path, times)返回指定的path文件的访问和修改的时间。</td></tr><tr><td style="text-align:left">62</td><td style="text-align:left">os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])输出在文件夹中的文件名通过在树中游走，向上或者向下。</td></tr><tr><td style="text-align:left">63</td><td style="text-align:left">os.write(fd, str)写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td></tr></tbody></table><h1 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h1><p>作为Python初学者，在刚学习Python编程时，经常会看到一些报错信息，在前面我们没有提及，这章节我们会专门介绍。<br>Python有两种错误很容易辨认：语法错误和异常。<br><strong>语法错误</strong><br>Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; while True print(&apos;Hello world&apos;)</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">    while True print(&apos;Hello world&apos;)</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号（:）。<br>语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。</p><p><strong>异常</strong><br>即便Python程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。<br>大多数的异常都不会被程序处理，都以错误信息的形式展现在这里:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 * (1/0)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">&gt;&gt;&gt; 4 + spam*3</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">NameError: name &apos;spam&apos; is not defined</span><br><span class="line">&gt;&gt;&gt; &apos;2&apos; + 2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly</span><br></pre></td></tr></table></figure><p>异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有<code>ZeroDivisionError</code>，<code>NameError</code>和 <code>TypeError</code>。<br>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。<br><strong>异常处理</strong><br>以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 <code>KeyboardInterrupt</code> 异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">        try:</span><br><span class="line">            x = int(input(&quot;Please enter a number: &quot;))</span><br><span class="line">            break</span><br><span class="line">        except ValueError:</span><br><span class="line">            print(&quot;Oops!  That was no valid number.  Try again   &quot;)</span><br></pre></td></tr></table></figure><p>try语句按照如下方式工作；<br>• 首先，执行try子句（在关键字try和关键字except之间的语句）<br>• 如果没有异常发生，忽略except子句，try子句执行后结束。<br>• 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。<br>• 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。<br>一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。<br>处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。<br>一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">except (RuntimeError, TypeError, NameError):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">try:</span><br><span class="line">    f = open(&apos;myfile.txt&apos;)</span><br><span class="line">    s = f.readline()</span><br><span class="line">    i = int(s.strip())</span><br><span class="line">except OSError as err:</span><br><span class="line">    print(&quot;OS error: &#123;0&#125;&quot;.format(err))</span><br><span class="line">except ValueError:</span><br><span class="line">    print(&quot;Could not convert data to an integer.&quot;)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])</span><br><span class="line">    raise</span><br><span class="line">try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。例如:</span><br><span class="line">for arg in sys.argv[1:]:</span><br><span class="line">    try:</span><br><span class="line">        f = open(arg, &apos;r&apos;)</span><br><span class="line">    except IOError:</span><br><span class="line">        print(&apos;cannot open&apos;, arg)</span><br><span class="line">    else:</span><br><span class="line">        print(arg, &apos;has&apos;, len(f.readlines()), &apos;lines&apos;)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。<br>异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def this_fails():</span><br><span class="line">        x = 1/0</span><br><span class="line">   </span><br><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        this_fails()</span><br><span class="line">    except ZeroDivisionError as err:</span><br><span class="line">        print(&apos;Handling run-time error:&apos;, err)</span><br><span class="line">   </span><br><span class="line">Handling run-time error: int division or modulo by zero</span><br></pre></td></tr></table></figure><p><strong>抛出异常</strong><br>Python 使用 raise 语句抛出一个指定的异常。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise NameError(&apos;HiThere&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure><p><code>raise</code> 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。<br>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        raise NameError(&apos;HiThere&apos;)</span><br><span class="line">    except NameError:</span><br><span class="line">        print(&apos;An exception flew by!&apos;)</span><br><span class="line">        raise</span><br><span class="line">   </span><br><span class="line">An exception flew by!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure><p><strong>用户自定义异常</strong><br>你可以通过创建一个新的exception类来拥有自己的异常。异常应该继承自 Exception 类，或者直接继承，或者间接继承，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyError(Exception):</span><br><span class="line">        def __init__(self, value):</span><br><span class="line">            self.value = value</span><br><span class="line">        def __str__(self):</span><br><span class="line">            return repr(self.value)</span><br><span class="line">   </span><br><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        raise MyError(2*2)</span><br><span class="line">    except MyError as e:</span><br><span class="line">        print(&apos;My exception occurred, value:&apos;, e.value)</span><br><span class="line">   </span><br><span class="line">My exception occurred, value: 4</span><br><span class="line">&gt;&gt;&gt; raise MyError(&apos;oops!&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">__main__.MyError: &apos;oops!&apos;</span><br></pre></td></tr></table></figure><p>在这个例子中，类 <code>Exception</code>默认的 <code>__init__()</code>被覆盖。<br>异常的类可以像其他的类一样做任何事情，但是通常都会比较简单，只提供一些错误相关的属性，并且允许处理异常的代码方便的获取这些信息。<br>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Error(Exception):</span><br><span class="line">    &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line">class InputError(Error):</span><br><span class="line">    &quot;&quot;&quot;Exception raised for errors in the input.</span><br><span class="line">Attributes:</span><br><span class="line">        expression -- input expression in which the error occurred</span><br><span class="line">        message -- explanation of the error</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">def __init__(self, expression, message):</span><br><span class="line">        self.expression = expression</span><br><span class="line">        self.message = message</span><br><span class="line">class TransitionError(Error):</span><br><span class="line">    &quot;&quot;&quot;Raised when an operation attempts a state transition that&apos;s not</span><br><span class="line">    allowed.</span><br><span class="line">Attributes:</span><br><span class="line">        previous -- state at beginning of transition</span><br><span class="line">        next -- attempted new state</span><br><span class="line">        message -- explanation of why the specific transition is not allowed</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">def __init__(self, previous, next, message):</span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.next = next</span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure><p>大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。</p><p><strong>定义清理行为</strong><br>try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        raise KeyboardInterrupt</span><br><span class="line">finally:</span><br><span class="line">        print(&apos;Goodbye, world!&apos;)</span><br><span class="line">   </span><br><span class="line">Goodbye, world!</span><br><span class="line">KeyboardInterrupt</span><br></pre></td></tr></table></figure><p>以上例子不管try子句里面有没有发生异常，finally子句都会执行。<br>如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。<br>下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally 子句）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def divide(x, y):</span><br><span class="line">        try:</span><br><span class="line">            result = x / y</span><br><span class="line">        except ZeroDivisionError:</span><br><span class="line">            print(&quot;division by zero!&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;result is&quot;, result)</span><br><span class="line">        finally:</span><br><span class="line">            print(&quot;executing finally clause&quot;)</span><br><span class="line">   </span><br><span class="line">&gt;&gt;&gt; divide(2, 1)</span><br><span class="line">result is 2.0</span><br><span class="line">executing finally clause</span><br><span class="line">&gt;&gt;&gt; divide(2, 0)</span><br><span class="line">division by zero!</span><br><span class="line">executing finally clause</span><br><span class="line">&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)</span><br><span class="line">executing finally clause</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in divide</span><br><span class="line">TypeError: unsupported operand type(s) for /: &apos;str&apos; and &apos;str&apos;</span><br></pre></td></tr></table></figure><p><strong>预定义的清理行为</strong><br>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。<br>这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for line in open(&quot;myfile.txt&quot;):</span><br><span class="line">    print(line, end=&quot;&quot;)</span><br></pre></td></tr></table></figure><p>以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。<br><code>关键词 with</code>语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;myfile.txt&quot;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        print(line, end=&quot;&quot;)</span><br></pre></td></tr></table></figure><p>以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。<br>异常的类可以像其他的类一样做任何事情，但是通常都会比较简单，只提供一些错误相关的属性，并且允许处理异常的代码方便的获取这些信息。</p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块，用一坨代码实现了某个功能的代码集合。<br>类似于函数式编程和面向过程编程，函数式编程则完成一个功能，其他代码用来调用即可，提供了代码的重用性和代码间的耦合。而对于一个复杂的功能来，可能需要多个函数才能完成（函数又可以在不同的.py文件中），n个 .py 文件组成的代码集合就称为模块。</p><p>如：os 是系统相关的模块；file是文件操作相关的模块<br>模块分为三种：</p><ol><li>自定义模块</li><li>第三方模块</li><li>内置模块<h2 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h2>1、<strong>定义模块</strong><br>情景一：<figure class="image-box">                <img src="./img/6.png" alt="" title="" class="">                <p></p>            </figure>情景二：<figure class="image-box">                <img src="./img/7.png" alt="" title="" class="">                <p></p>            </figure>情景三：<figure class="image-box">                <img src="./img/8.png" alt="" title="" class="">                <p></p>            </figure>2、<strong>导入模块</strong><br>Python之所以应用越来越广泛，在一定程度上也依赖于其为程序员提供了大量的模块以供使用，如果想要使用模块，则需要导入。导入模块有一下几种方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import module</span><br><span class="line">from module.xx.xx import xx</span><br><span class="line">from module.xx.xx import xx as rename </span><br><span class="line">from module.xx.xx import *</span><br></pre></td></tr></table></figure><p>导入模块其实就是告诉Python解释器去解释那个py文件</p><blockquote><p>导入一个py文件，解释器解释该py文件<br>导入一个包，解释器解释该包下的 <strong>init</strong>.py 文件 【py2.7】</p></blockquote><p>那么问题来了，导入模块时是根据那个路径作为基准来进行的呢？即：sys.path<br><figure class="image-box">                <img src="./img/5.png" alt="" title="" class="">                <p></p>            </figure></p><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><p>用于提供对Python解释器相关的操作：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">sys.argv</td><td style="text-align:left">命令行参数List，第一个元素是程序本身路径</td></tr><tr><td style="text-align:left">sys.exit(n)</td><td style="text-align:left">退出程序，正常退出时exit(0)</td></tr><tr><td style="text-align:left">sys.version</td><td style="text-align:left">获取Python解释程序的版本信息</td></tr><tr><td style="text-align:left">sys.maxint</td><td style="text-align:left">最大的Int值</td></tr><tr><td style="text-align:left">sys.path</td><td style="text-align:left">返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</td></tr><tr><td style="text-align:left">sys.platform</td><td style="text-align:left">返回操作系统平台名称</td></tr><tr><td style="text-align:left">sys.stdin</td><td style="text-align:left">输入相关</td></tr><tr><td style="text-align:left">sys.stdout</td><td style="text-align:left">输出相关</td></tr><tr><td style="text-align:left">sys.stderror</td><td style="text-align:left">错误相关</td></tr></tbody></table><h2 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h2><p>用于加密相关的操作，代替了<code>md5模块</code>和<code>sha模块</code>，主要提供 <strong>SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5</strong> 算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"># ######## md5 ########</span><br><span class="line">hash = hashlib.md5()</span><br><span class="line"># help(hash.update)</span><br><span class="line">hash.update(bytes(&apos;admin&apos;, encoding=&apos;utf-8&apos;))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line">print(hash.digest())</span><br><span class="line"> </span><br><span class="line">######## sha1 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha1()</span><br><span class="line">hash.update(bytes(&apos;admin&apos;, encoding=&apos;utf-8&apos;))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha256 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha256()</span><br><span class="line">hash.update(bytes(&apos;admin&apos;, encoding=&apos;utf-8&apos;))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha384 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha384()</span><br><span class="line">hash.update(bytes(&apos;admin&apos;, encoding=&apos;utf-8&apos;))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha512 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha512()</span><br><span class="line">hash.update(bytes(&apos;admin&apos;, encoding=&apos;utf-8&apos;))</span><br><span class="line">print(hash.hexdigest())</span><br></pre></td></tr></table></figure><p>以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"># ######## md5 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.md5(bytes(&apos;898oaFs09f&apos;,encoding=&quot;utf-8&quot;))</span><br><span class="line">hash.update(bytes(&apos;admin&apos;,encoding=&quot;utf-8&quot;))</span><br><span class="line">print(hash.hexdigest())</span><br></pre></td></tr></table></figure><p>python内置还有一个 <code>hmac</code> 模块，它内部对我们创建 key 和 内容 进行进一步的处理然后再加密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import hmac</span><br><span class="line"> </span><br><span class="line">h = hmac.new(bytes(&apos;898oaFs09f&apos;,encoding=&quot;utf-8&quot;))</span><br><span class="line">h.update(bytes(&apos;admin&apos;,encoding=&quot;utf-8&quot;))</span><br><span class="line">print(h.hexdigest())</span><br></pre></td></tr></table></figure><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>随机数的模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"> </span><br><span class="line">print(random.random())</span><br><span class="line">print(random.randint(1, 2))</span><br><span class="line">print(random.randrange(1, 10))</span><br></pre></td></tr></table></figure><p><em>随机验证码：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">checkcode = &apos;&apos;</span><br><span class="line">for i in range(4):</span><br><span class="line">    current = random.randrange(0,4)</span><br><span class="line">    if current != i:</span><br><span class="line">        temp = chr(random.randint(65,90))</span><br><span class="line">    else:</span><br><span class="line">        temp = random.randint(0,9)</span><br><span class="line">    checkcode += str(temp)</span><br><span class="line">print checkcode</span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>Python中用于序列化的两个模块</p><p><strong>json</strong>     用于【字符串】和 【python基本数据类型】 间进行转换<br><strong>pickle</strong>   用于【python特有的类型】 和 【python基本数据类型】间进行转换<br>Json模块提供了四个功能：<code>dumps、dump、loads、load</code><br>pickle模块提供了四个功能：<code>dumps、dump、loads、load</code><br><figure class="image-box">                <img src="./img/9.png" alt="" title="" class="">                <p></p>            </figure></p><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>Python标准库中提供了：urllib等模块以供Http请求，但是，它的 API 太渣了。它是为另一个时代、另一个互联网所创建的。它需要巨量的工作，甚至包括各种方法覆盖，来完成最简单的任务。<br><em>发送GET请求</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">f = urllib.request.urlopen(&apos;http://www.webxml.com.cn//webservices/qqOnlineWebService.asmx/qqCheckOnline?qqCode=424662508&apos;)</span><br><span class="line">result = f.read().decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure><p><em>发送携带参数的get请求</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">req = urllib.request.Request(&apos;http://www.example.com/&apos;)</span><br><span class="line">req.add_header(&apos;Referer&apos;, &apos;http://www.python.org/&apos;)</span><br><span class="line">r = urllib.request.urlopen(req)</span><br><span class="line"></span><br><span class="line">result = f.read().decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure><p><strong>Requests</strong> 是使用 Apache2 Licensed 许可证的 基于Python开发的HTTP 库，其在Python内置模块的基础上进行了高度的封装，从而使得Pythoner进行网络请求时，变得美好了许多，使用Requests可以轻而易举的完成浏览器可有的任何操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># 1、无参数实例</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line"> </span><br><span class="line">ret = requests.get(&apos;https://github.com/timeline.json&apos;)</span><br><span class="line"> </span><br><span class="line">print(ret.url)</span><br><span class="line">print(ret.text)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 2、有参数实例</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line"> </span><br><span class="line">payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line">ret = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)</span><br><span class="line"> </span><br><span class="line">print(ret.url)</span><br><span class="line">print(ret.text)</span><br><span class="line">复制代码</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line"># 1、基本POST实例</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line"> </span><br><span class="line">payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line">ret = requests.post(&quot;http://httpbin.org/post&quot;, data=payload)</span><br><span class="line"> </span><br><span class="line">print(ret.text)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 2、发送请求头和数据实例</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line"> </span><br><span class="line">url = &apos;https://api.github.com/some/endpoint&apos;</span><br><span class="line">payload = &#123;&apos;some&apos;: &apos;data&apos;&#125;</span><br><span class="line">headers = &#123;&apos;content-type&apos;: &apos;application/json&apos;&#125;</span><br><span class="line"> </span><br><span class="line">ret = requests.post(url, data=json.dumps(payload), headers=headers)</span><br><span class="line"> </span><br><span class="line">print(ret.text)</span><br><span class="line">print(ret.cookies)</span><br><span class="line"></span><br><span class="line">requests.get(url, params=None, **kwargs)</span><br><span class="line">requests.post(url, data=None, json=None, **kwargs)</span><br><span class="line">requests.put(url, data=None, **kwargs)</span><br><span class="line">requests.head(url, **kwargs)</span><br><span class="line">requests.delete(url, **kwargs)</span><br><span class="line">requests.patch(url, data=None, **kwargs)</span><br><span class="line">requests.options(url, **kwargs)</span><br><span class="line"> </span><br><span class="line"># 以上方法均是在此方法的基础上构建</span><br><span class="line">requests.request(method, url, **kwargs)</span><br></pre></td></tr></table></figure><h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><p>用于便捷记录日志且线程安全的模块<br><em>1、单文件日志</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(filename=&apos;log.log&apos;,</span><br><span class="line">                    format=&apos;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&apos;,</span><br><span class="line">                    datefmt=&apos;%Y-%m-%d %H:%M:%S %p&apos;,</span><br><span class="line">                    level=10)</span><br><span class="line">  </span><br><span class="line">logging.debug(&apos;debug&apos;)</span><br><span class="line">logging.info(&apos;info&apos;)</span><br><span class="line">logging.warning(&apos;warning&apos;)</span><br><span class="line">logging.error(&apos;error&apos;)</span><br><span class="line">logging.critical(&apos;critical&apos;)</span><br><span class="line">logging.log(10,&apos;log&apos;)</span><br></pre></td></tr></table></figure><p><em>日志等级：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CRITICAL = 50</span><br><span class="line">FATAL = CRITICAL</span><br><span class="line">ERROR = 40</span><br><span class="line">WARNING = 30</span><br><span class="line">WARN = WARNING</span><br><span class="line">INFO = 20</span><br><span class="line">DEBUG = 10</span><br><span class="line">NOTSET = 0</span><br></pre></td></tr></table></figure><p>注：只有【当前写等级】大于【日志等级】时，日志文件才被记录。<br>日志记录格式：<br><figure class="image-box">                <img src="./img/10.png" alt="" title="" class="">                <p></p>            </figure></p><p><em>2、多文件日志</em></p><p>对于上述记录日志的功能，只能将日志记录在单文件中，如果想要设置多个日志文件，logging.basicConfig将无法完成，需要自定义文件和日志操作对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 定义文件</span><br><span class="line">file_1_1 = logging.FileHandler(&apos;l1_1.log&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">fmt = logging.Formatter(fmt=&quot;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&quot;)</span><br><span class="line">file_1_1.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line">file_1_2 = logging.FileHandler(&apos;l1_2.log&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">fmt = logging.Formatter()</span><br><span class="line">file_1_2.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line"># 定义日志</span><br><span class="line">logger1 = logging.Logger(&apos;s1&apos;, level=logging.ERROR)</span><br><span class="line">logger1.addHandler(file_1_1)</span><br><span class="line">logger1.addHandler(file_1_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 写日志</span><br><span class="line">logger1.critical(&apos;1111&apos;)</span><br><span class="line"></span><br><span class="line"># 定义文件</span><br><span class="line">file_2_1 = logging.FileHandler(&apos;l2_1.log&apos;, &apos;a&apos;)</span><br><span class="line">fmt = logging.Formatter()</span><br><span class="line">file_2_1.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line"># 定义日志</span><br><span class="line">logger2 = logging.Logger(&apos;s2&apos;, level=logging.INFO)</span><br><span class="line">logger2.addHandler(file_2_1)</span><br></pre></td></tr></table></figure><p>如上述创建的两个日志对象<br>当使用【logger1】写日志时，会将相应的内容写入 l1_1.log 和 l1_2.log 文件中<br>当使用【logger2】写日志时，会将相应的内容写入 l2_1.log 文件中</p><h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><p>时间相关的操作，时间有三种表示方式：</p><p>时间戳               1970年1月1日之后的秒，即：time.time()<br>格式化的字符串    2014-11-11 11:11，    即：time.strftime(‘%Y-%m-%d’)<br>结构化时间          元组包含了：年、日、星期等… time.struct_time    即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">time.localtime()</span><br><span class="line"></span><br><span class="line">print time.time()</span><br><span class="line">print time.mktime(time.localtime())</span><br><span class="line">   </span><br><span class="line">print time.gmtime()    #可加时间戳参数</span><br><span class="line">print time.localtime() #可加时间戳参数</span><br><span class="line">print time.strptime(&apos;2014-11-11&apos;, &apos;%Y-%m-%d&apos;)</span><br><span class="line">   </span><br><span class="line">print time.strftime(&apos;%Y-%m-%d&apos;) #默认当前时间</span><br><span class="line">print time.strftime(&apos;%Y-%m-%d&apos;,time.localtime()) #默认当前时间</span><br><span class="line">print time.asctime()</span><br><span class="line">print time.asctime(time.localtime())</span><br><span class="line">print time.ctime(time.time())</span><br><span class="line">   </span><br><span class="line">import datetime</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">datetime.date：表示日期的类。常用的属性有year, month, day</span><br><span class="line">datetime.time：表示时间的类。常用的属性有hour, minute, second, microsecond</span><br><span class="line">datetime.datetime：表示日期时间</span><br><span class="line">datetime.timedelta：表示时间间隔，即两个时间点之间的长度</span><br><span class="line">timedelta([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]])</span><br><span class="line">strftime(&quot;%Y-%m-%d&quot;)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">import datetime</span><br><span class="line">print datetime.datetime.now()</span><br><span class="line">print datetime.datetime.now() - datetime.timedelta(days=5)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拥抱Python</title>
      <link href="/2017/03/12/%E6%8B%A5%E6%8A%B1Python/"/>
      <url>/2017/03/12/%E6%8B%A5%E6%8A%B1Python/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="知识拾遗"><a href="#知识拾遗" class="headerlink" title="知识拾遗"></a>知识拾遗</h1><h2 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h2><p>对于Python变量的作用域，执行声明并在内存中存在，该变量就可以在下面的代码中使用,Python变量的作用域遵循<strong>LEGB</strong>法则即：</p><blockquote><p>局部作用域——-》嵌套作用域——–》全局作用域——-》内置作用域（内置函数）</p></blockquote><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><blockquote><p>result = 值1 if 条件 else 值2<br>如果条件为真：result = 值1<br>如果条件为假：result = 值2</p></blockquote><h2 id="几个常用的内置函数"><a href="#几个常用的内置函数" class="headerlink" title="几个常用的内置函数"></a>几个常用的内置函数</h2><p>. <strong>lambda(匿名函数)</strong><br>传入多个参数的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sum(x,y):</span><br><span class="line">return x+y</span><br></pre></td></tr></table></figure></p><p>用lambda来实现：</p><blockquote><p>p = lambda x,y:x+y<br>print(p(4,6))等价于print(sum(4,6))</p></blockquote><p>. <strong>map函数</strong><br>map() 会根据提供的函数对指定序列做映射。<br>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p><p><em>语法：</em></p><blockquote><p>map(function, iterable, …)</p></blockquote><p><em>实例：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;def square(x) :            # 计算平方数</span><br><span class="line">...     return x ** 2</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; map(square, [1,2,3,4,5])   # 计算列表各个元素的平方</span><br><span class="line">[1, 4, 9, 16, 25]</span><br><span class="line">&gt;&gt;&gt; map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 使用 lambda 匿名函数</span><br><span class="line">[1, 4, 9, 16, 25]</span><br><span class="line"> </span><br><span class="line"># 提供了两个列表，对相同位置的列表数据进行相加</span><br><span class="line">&gt;&gt;&gt; map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])</span><br><span class="line">[3, 7, 11, 15, 19]</span><br></pre></td></tr></table></figure><p>. <strong>reduce函数</strong><br>reduce() 函数会对参数序列中元素进行累积。<br>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。<br><em>语法</em></p><blockquote><p>reduce(function, iterable[, initializer])<br><em>实例</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;def add(x, y) :            # 两数相加</span><br><span class="line">...     return x + y</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; reduce(add, [1,2,3,4,5])   # 计算列表和：1+2+3+4+5</span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; reduce(lambda x, y: x+y, [1,2,3,4,5])  # 使用 lambda 匿名函数</span><br><span class="line">15</span><br></pre></td></tr></table></figure><p>. <strong>filter函数</strong><br>filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。<br>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。<br><em>语法</em></p><blockquote><p>filter(function, iterable)<br><em>实例</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"> </span><br><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"> </span><br><span class="line">newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</span><br><span class="line">print(newlist)</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>[1, 3, 5, 7, 9]</p></blockquote><p><strong>repr函数</strong><br>repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注意，在大多数时候有eval(repr(object)) == object。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; i = []</span><br><span class="line">&gt;&gt;&gt; i.append(&apos;item&apos;)</span><br><span class="line">&gt;&gt;&gt; `i`</span><br><span class="line">&quot;[&apos;item&apos;]&quot;</span><br><span class="line">&gt;&gt;&gt; repr(i)</span><br><span class="line">&quot;[&apos;item&apos;]&quot;</span><br></pre></td></tr></table></figure><p>基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的<strong>repr</strong>方法来控制你的对象在被repr函数调用的时候返回的内容。</p><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><p><strong>对于Python一切事物都是对象，对象基于类创建</strong><br><figure class="image-box">                <img src="./img/1.png" alt="" title="" class="">                <p></p>            </figure></p><h2 id="Python的基本数据类型"><a href="#Python的基本数据类型" class="headerlink" title="Python的基本数据类型"></a>Python的基本数据类型</h2><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。<br>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。<br>等号（=）用来给变量赋值。<br>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如：</p><p><em>实例(Python 3.0+)</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3 </span><br><span class="line">counter = 100 # 整型变量</span><br><span class="line">miles = 1000.0 # 浮点型变量 </span><br><span class="line">name = &quot;BAIDU&quot; # 字符串 </span><br><span class="line">print (counter) </span><br><span class="line">print (miles) </span><br><span class="line">print (name)</span><br></pre></td></tr></table></figure><p>运行实例 »<br>执行以上程序会输出如下结果：</p><blockquote><p>100<br>1000.0<br>BAIDU</p></blockquote><p><strong><em>多个变量赋值</em></strong><br>Python允许你同时为多个变量赋值。例如：<br>a = b = c = 1<br>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。<br>您也可以为多个对象指定多个变量。例如：<br>a, b, c = 1, 2, “BAIDU”<br>以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “BAIDU” 分配给变量 c。</p><p><strong><em>标准数据类型</em></strong><br>Python3 中有六个标准的数据类型：<br>• Number（数字）<br>• String（字符串）<br>• List（列表）<br>• Tuple（元组）<br>• Sets（集合）<br>• Dictionary（字典）</p><p><strong><em>Number（数字）</em></strong><br>Python3 支持 int、float、bool、complex（复数）。<br>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。<br>像大多数语言一样，数值类型的赋值和计算都是很直观的。<br>内置的 type() 函数可以用来查询变量所指的对象类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j</span><br><span class="line">&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))</span><br><span class="line">&lt;class &apos;int&apos;&gt; &lt;class &apos;float&apos;&gt; &lt;class &apos;bool&apos;&gt; &lt;class &apos;complex&apos;&gt;</span><br><span class="line">此外还可以用 isinstance 来判断：</span><br><span class="line">&gt;&gt;&gt; a = 111</span><br><span class="line">&gt;&gt;&gt; isinstance(a, int)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>isinstance 和 type 的区别在于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    pass</span><br><span class="line">class B(A):</span><br><span class="line">    pass</span><br><span class="line">isinstance(A(), A)  # returns True</span><br><span class="line">type(A()) == A      # returns True</span><br><span class="line">isinstance(B(), A)    # returns True</span><br><span class="line">type(B()) == A        # returns False</span><br></pre></td></tr></table></figure><p>区别就是:<br>• type()不会认为子类是一种父类类型。<br>• isinstance()会认为子类是一种父类类型。<br>注意：在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。<br>当你指定一个值时，Number 对象就会被创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = 1</span><br><span class="line">var2 = 10</span><br></pre></td></tr></table></figure><p>您也可以使用del语句删除一些对象引用。<br>del语句的语法是：</p><blockquote><p>del var1[,var2[,var3[….,varN]]]]<br>您可以通过使用del语句删除单个或多个对象。例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del var</span><br><span class="line">del var_a, var_b</span><br></pre></td></tr></table></figure><p>数值运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 5 + 4  # 加法</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; 4.3 - 2 # 减法</span><br><span class="line">2.3</span><br><span class="line">&gt;&gt;&gt; 3 * 7  # 乘法</span><br><span class="line">21</span><br><span class="line">&gt;&gt;&gt; 2 / 4  # 除法，得到一个浮点数</span><br><span class="line">0.5</span><br><span class="line">&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 17 % 3 # 取余 </span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 2 ** 5 # 乘方</span><br><span class="line">32</span><br></pre></td></tr></table></figure><p>注意：<br>• 1、Python可以同时为多个变量赋值，如a, b = 1, 2。<br>• 2、一个变量可以通过赋值指向不同类型的对象。<br>• 3、数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。<br>• 4、在混合计算时，Python会把整型转换成为浮点数。</p><p><strong><em>String（字符串）</em></strong><br>Python中的字符串用单引号(‘)或双引号(“)括起来，同时使用反斜杠()转义特殊字符。<br>字符串的截取的语法格式如下：<br>变量[头下标:尾下标]<br>索引值以 0 为开始值，-1 为从末尾的开始位置。<br>加号 (+) 是字符串的连接符， 星号 (*) 表示复制当前字符串，紧跟的数字为复制的次数。实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">str = &apos;chinatop&apos;</span><br><span class="line">print (str)          # 输出字符串   chinatop</span><br><span class="line">print (str[0:-1])    # 输出第一个个到倒数第二个的所有字符   chinato</span><br><span class="line">print (str[0])       # 输出字符串第一个字符</span><br><span class="line">print (str[2:5])     # 输出从第三个开始到第五个的字符</span><br><span class="line">print (str[2:])      # 输出从第三个开始的后的所有字符</span><br><span class="line">print (str * 2)      # 输出字符串两次</span><br><span class="line">print (str + &quot;TEST&quot;) # 连接字符串</span><br></pre></td></tr></table></figure><p>执行以上程序会输出如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BAIDU</span><br><span class="line">Runoo</span><br><span class="line">R</span><br><span class="line">noo</span><br><span class="line">noob</span><br><span class="line">BAIDUBAIDU</span><br><span class="line">BAIDUTEST</span><br></pre></td></tr></table></figure><p>Python 使用反斜杠()转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;Ru\noob&apos;)</span><br><span class="line">Ru</span><br><span class="line">oob</span><br><span class="line">&gt;&gt;&gt; print(r&apos;Ru\noob&apos;)</span><br><span class="line">Ru\noob</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>另外，反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 “””…””” 或者 ‘’’…’’’ 跨越多行。<br>注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; word = &apos;Python&apos;</span><br><span class="line">&gt;&gt;&gt; print(word[0], word[5])</span><br><span class="line">P n</span><br><span class="line">&gt;&gt;&gt; print(word[-1], word[-6])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure><p>与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。<br>注意：<br>• 1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。<br>• 2、字符串可以用+运算符连接在一起，用*运算符重复。<br>• 3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。<br>4、Python中的字符串不能改变。</p><p><strong><em>List（列表）</em></strong><br>List（列表） 是 Python 中使用最频繁的数据类型。<br>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。<br>列表是写在方括号([])之间、用逗号分隔开的元素列表。<br>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。<br>列表截取的语法格式如下：<br>变量[头下标:尾下标]<br>索引值以 0 为开始值，-1 为从末尾的开始位置。<br>加号（+）是列表连接运算符，星号（*）是重复操作。如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">list = [ &apos;abcd&apos;, 786 , 2.23, &apos;BAIDU&apos;, 70.2 ]</span><br><span class="line">tinylist = [123, &apos;BAIDU&apos;]</span><br><span class="line">print (list)            # 输出完整列表</span><br><span class="line">print (list[0])         # 输出列表第一个元素</span><br><span class="line">print (list[1:3])       # 从第二个开始输出到第三个元素</span><br><span class="line">print (list[2:])        # 输出从第三个元素开始的所有元素</span><br><span class="line">print (tinylist * 2)    # 输出两次列表</span><br><span class="line">print (list + tinylist) # 连接列表</span><br></pre></td></tr></table></figure><p>以上实例输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&apos;abcd&apos;, 786, 2.23, &apos;BAIDU&apos;, 70.2]</span><br><span class="line">abcd</span><br><span class="line">[786, 2.23]</span><br><span class="line">[2.23, &apos;BAIDU&apos;, 70.2]</span><br><span class="line">[123, &apos;BAIDU&apos;, 123, &apos;BAIDU&apos;]</span><br><span class="line">[&apos;abcd&apos;, 786, 2.23, &apos;BAIDU&apos;, 70.2, 123, &apos;BAIDU&apos;]</span><br></pre></td></tr></table></figure></p><p>与Python字符串不一样的是，列表中的元素是可以改变的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; a[0] = 9</span><br><span class="line">&gt;&gt;&gt; a[2:5] = [13, 14, 15]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[9, 2, 13, 14, 15, 6]</span><br><span class="line">&gt;&gt;&gt; a[2:5] = []   # 删除</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[9, 2, 6]</span><br></pre></td></tr></table></figure><p>List内置了有很多方法，例如<code>append()</code>、<code>pop()</code>等等，这在后面会讲到。<br>注意：<br>• 1、List写在方括号之间，元素用逗号隔开。<br>• 2、和字符串一样，list可以被索引和切片。<br>• 3、List可以使用+操作符进行拼接。<br>• 4、List中的元素是可以改变的。</p><p><strong><em>Tuple（元组）</em></strong><br>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号(())里，元素之间用逗号隔开。<br>元组中的元素类型也可以不相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">tuple = ( &apos;abcd&apos;, 786 , 2.23, &apos;BAIDU&apos;, 70.2  )</span><br><span class="line">tinytuple = (123, &apos;BAIDU&apos;)</span><br><span class="line">print (tuple)             # 输出完整元组</span><br><span class="line">print (tuple[0])          # 输出元组的第一个元素</span><br><span class="line">print (tuple[1:3])        # 输出从第二个元素开始到第三个元素</span><br><span class="line">print (tuple[2:])         # 输出从第三个元素开始的所有元素</span><br><span class="line">print (tinytuple * 2)     # 输出两次元组</span><br><span class="line">print (tuple + tinytuple) # 连接元组</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(&apos;abcd&apos;, 786, 2.23, &apos;BAIDU&apos;, 70.2)</span><br><span class="line">abcd</span><br><span class="line">(786, 2.23)</span><br><span class="line">(2.23, &apos;BAIDU&apos;, 70.2)</span><br><span class="line">(123, &apos;BAIDU&apos;, 123, &apos;BAIDU&apos;)</span><br><span class="line">(&apos;abcd&apos;, 786, 2.23, &apos;BAIDU&apos;, 70.2, 123, &apos;BAIDU&apos;)</span><br></pre></td></tr></table></figure><p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。<br>其实，可以把字符串看作一种特殊的元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tup = (1, 2, 3, 4, 5, 6)</span><br><span class="line">&gt;&gt;&gt; print(tup[0])</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(tup[1:5])</span><br><span class="line">(2, 3, 4, 5)</span><br><span class="line">&gt;&gt;&gt; tup[0] = 11  # 修改元组元素的操作是非法的</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &apos;tuple&apos; object does not support item assignment</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。<br>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：<br>tup1 = ()    # 空元组<br>tup2 = (20,) # 一个元素，需要在元素后添加逗号<br>string、list和tuple都属于sequence（序列）。<br>注意：<br>• 1、与字符串一样，元组的元素不能修改。<br>• 2、元组也可以被索引和切片，方法一样。<br>• 3、注意构造包含0或1个元素的元组的特殊语法规则。<br>• 4、元组也可以使用+操作符进行拼接。</p><p><strong><em>Set（集合）</em></strong><br>集合（set）是一个无序不重复元素的序列。<br>基本功能是进行成员关系测试和删除重复元素。<br>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">student = &#123;&apos;Tom&apos;, &apos;Jim&apos;, &apos;Mary&apos;, &apos;Tom&apos;, &apos;Jack&apos;, &apos;Rose&apos;&#125;</span><br><span class="line">print(student)   # 输出集合，重复的元素被自动去掉</span><br><span class="line"># 成员测试</span><br><span class="line">if(&apos;Rose&apos; in student) :</span><br><span class="line">    print(&apos;Rose 在集合中&apos;)</span><br><span class="line">else :</span><br><span class="line">    print(&apos;Rose 不在集合中&apos;)</span><br><span class="line"># set可以进行集合运算</span><br><span class="line">a = set(&apos;abracadabra&apos;)</span><br><span class="line">b = set(&apos;alacazam&apos;)</span><br><span class="line">print(a)</span><br><span class="line">print(a - b)     # a和b的差集</span><br><span class="line">print(a | b)     # a和b的并集</span><br><span class="line">print(a &amp; b)     # a和b的交集</span><br><span class="line">print(a ^ b)     # a和b中不同时存在的元素</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><blockquote><p>{‘Mary’, ‘Jim’, ‘Rose’, ‘Jack’, ‘Tom’}<br>Rose 在集合中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;r&apos;, &apos;d&apos;&#125;</span><br><span class="line">&#123;&apos;b&apos;, &apos;d&apos;, &apos;r&apos;&#125;</span><br><span class="line">&#123;&apos;l&apos;, &apos;r&apos;, &apos;a&apos;, &apos;c&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;&#125;</span><br><span class="line">&#123;&apos;a&apos;, &apos;c&apos;&#125;</span><br><span class="line">&#123;&apos;l&apos;, &apos;r&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Dictionary（字典）</em></strong><br>字典（dictionary）是Python中另一个非常有用的内置数据类型。<br>列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。<br>字典是一种映射类型，字典用”{ }”标识，它是一个无序的键(key) : 值(value)对集合。<br>键(key)必须使用不可变类型。<br>在同一个字典中，<code>键(key)</code>必须是唯一的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">dict = &#123;&#125;</span><br><span class="line">dict[&apos;one&apos;] = &quot;1 - Kevin&quot;</span><br><span class="line">dict[2]     = &quot;2 - Peter&quot;</span><br><span class="line">tinydict = &#123;&apos;name&apos;: &apos;BAIDU&apos;,&apos;code&apos;:1, &apos;site&apos;: &apos;www.BAIDU.com&apos;&#125;</span><br><span class="line">print (dict[&apos;one&apos;])       # 输出键为 &apos;one&apos; 的值</span><br><span class="line">print (dict[2])           # 输出键为 2 的值</span><br><span class="line">print (tinydict)          # 输出完整的字典</span><br><span class="line">print (tinydict.keys())   # 输出所有键</span><br><span class="line">print (tinydict.values()) # 输出所有值</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><blockquote><p>1 -Kevin<br>  2 - Peter<br>  {‘name’: ‘BAIDU’, ‘site’: ‘<a href="http://www.BAIDU.com&#39;" target="_blank" rel="noopener">www.BAIDU.com&#39;</a>, ‘code’: 1}<br>  dict_keys([‘name’, ‘site’, ‘code’])<br>  dict_values([‘BAIDU’, ‘<a href="http://www.BAIDU.com&#39;" target="_blank" rel="noopener">www.BAIDU.com&#39;</a>, 1])<br>构造函数 dict() 可以直接从键值对序列中构建字典如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dict([(&apos;BAIDU&apos;, 1), (&apos;Google&apos;, 2), (&apos;Taobao&apos;, 3)])</span><br><span class="line">&#123;&apos;Taobao&apos;: 3, &apos;BAIDU&apos;: 1, &apos;Google&apos;: 2&#125;</span><br><span class="line">&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;</span><br><span class="line">&#123;2: 4, 4: 16, 6: 36&#125;</span><br><span class="line">&gt;&gt;&gt; dict(BAIDU=1, Google=2, Taobao=3)</span><br><span class="line">&#123;&apos;Taobao&apos;: 3, &apos;BAIDU&apos;: 1, &apos;Google&apos;: 2&#125;</span><br></pre></td></tr></table></figure><p>另外，字典类型也有一些内置的函数，例如<code>clear()</code>、<code>keys()</code>、<code>values()</code>等。<br>注意：<br>• 1、字典是一种映射类型，它的元素是键值对。<br>• 2、字典的关键字必须为不可变类型，且不能重复。<br>3、创建空字典使用 { }。</p><p><strong><em>Python数据类型转换</em></strong><br>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。<br>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">int(x [,base])</td><td style="text-align:center">将x转换为一个整数</td></tr><tr><td style="text-align:center">float(x)</td><td style="text-align:center">将x转换到一个浮点数</td></tr><tr><td style="text-align:center">complex(real [,imag])</td><td style="text-align:center">创建一个复数</td></tr><tr><td style="text-align:center">str(x)</td><td style="text-align:center">将对象 x 转换为字符串</td></tr><tr><td style="text-align:center">repr(x)</td><td style="text-align:center">将对象 x 转换为表达式字符串</td></tr><tr><td style="text-align:center">eval(str)</td><td style="text-align:center">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td style="text-align:center">tuple(s)</td><td style="text-align:center">将序列 s 转换为一个元组</td></tr><tr><td style="text-align:center">list(s)</td><td style="text-align:center">将序列 s 转换为一个列表</td></tr><tr><td style="text-align:center">set(s)</td><td style="text-align:center">转换为可变集合</td></tr><tr><td style="text-align:center">dict(d)</td><td style="text-align:center">创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td style="text-align:center">frozenset(s)</td><td style="text-align:center">转换为不可变集合</td></tr><tr><td style="text-align:center">chr(x)</td><td style="text-align:center">将一个整数转换为一个字符</td></tr><tr><td style="text-align:center">unichr(x)</td><td style="text-align:center">将一个整数转换为Unicode字符</td></tr><tr><td style="text-align:center">ord(x)</td><td style="text-align:center">将一个字符转换为它的整数值</td></tr><tr><td style="text-align:center">hex(x)</td><td style="text-align:center">将一个整数转换为一个十六进制字符串</td></tr><tr><td style="text-align:center">oct(x)</td><td style="text-align:center">将一个整数转换为一个八进制字符串</td></tr></tbody></table><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong><em>字符串的索引(下标)</em></strong><br>    • 字符串中”下标”的使用<br><figure class="image-box">                <img src="./img/2.png" alt="" title="" class="">                <p></p>            </figure><br>如果想取出部分字符，那么可以通过下标的方法，（注意python中下标从 0 开始）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;abcdef&apos;</span><br><span class="line">print(name[0])</span><br><span class="line">print(name[1])</span><br><span class="line">print(name[2])</span><br></pre></td></tr></table></figure><p>运行结果: </p><blockquote><p>a<br>  b<br>  c</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(name[0:3]) # 取 下标0~2 的字符</span><br><span class="line">print(name[2:]) # 取 下标为2开始到最后的字符</span><br><span class="line">print(name[1:-1]) # 取 下标为1开始 到 最后第2个  之间的字符</span><br></pre></td></tr></table></figure><p><strong><em>格式化操作符（%）</em></strong><br>“%”是Python风格的字符串格式化操作符，非常类似C语言里的printf()函数的字符串格式化（C语言中也是使用%）。<br>下面整理了一下Python中字符串格式化符合：</p><table><thead><tr><th style="text-align:left">格式化符号</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">%c</td><td style="text-align:left">转换成字符（ASCII 码值，或者长度为一的字符串）</td></tr><tr><td style="text-align:left">%r</td><td style="text-align:left">优先用repr()函数进行字符串转换</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">优先用str()函数进行字符串转换</td></tr><tr><td style="text-align:left">%d / %i</td><td style="text-align:left">转成有符号十进制数</td></tr><tr><td style="text-align:left">%u</td><td style="text-align:left">转成无符号十进制数</td></tr><tr><td style="text-align:left">%o</td><td style="text-align:left">转成无符号八进制数</td></tr><tr><td style="text-align:left">%x / %X</td><td style="text-align:left">转成无符号十六进制数（x / X 代表转换后的十六进制字符的大小写）</td></tr><tr><td style="text-align:left">%e / %E</td><td style="text-align:left">转成科学计数法（e / E控制输出e / E）</td></tr><tr><td style="text-align:left">%f / %F</td><td style="text-align:left">转成浮点数（小数部分自然截断）</td></tr><tr><td style="text-align:left">%g / %G</td><td style="text-align:left">%e和%f / %E和%F 的简写</td></tr><tr><td style="text-align:left">%%</td><td style="text-align:left">输出% （格式化字符串里面包括百分号，那么必须使用%%）</td></tr></tbody></table><p><strong><em>字符串内建函数format()</em></strong><br>Python2.6开始，新增了一种格式化字符串的函数str.format()，通过这个函数同样可以对字符串进行格式化处理。在format()函数中，使用“{}”符号来当作格式化操作符。<br>下面直接通过一些简单的例子演示format()函数的基本使用：</p><p><strong>位置参数</strong></p><pre><code>print &quot;{0} is {1} years old&quot;.format(&quot;Wilber&quot;, 28)print &quot;{} is {} years old&quot;.format(&quot;Wilber&quot;, 28)print &quot;Hi, {0}! {0} is {1} years old&quot;.format(&quot;Wilber&quot;, 28)</code></pre><p><strong>关键字参数</strong></p><pre><code>print &quot;{name} is {age} years old&quot;.format(name = &quot;Wilber&quot;, age = 28)</code></pre><p><strong>下标参数</strong></p><pre><code>li = [&quot;Wilber&quot;, 28]print &quot;{0[0]} is {0[1]} years old&quot;.format(li)</code></pre><p><strong>填充与对齐</strong><br>^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度<br>:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充</p><pre><code>print &apos;{:&gt;8}&apos;.format(&apos;3.14&apos;)print &apos;{:&lt;8}&apos;.format(&apos;3.14&apos;)print &apos;{:^8}&apos;.format(&apos;3.14&apos;)print &apos;{:0&gt;8}&apos;.format(&apos;3.14&apos;)print &apos;{:a&gt;8}&apos;.format(&apos;3.14&apos;)</code></pre><p><strong>浮点数精度</strong></p><pre><code>print &apos;{:.4f}&apos;.format(3.1415926)print &apos;{:0&gt;10.4f}&apos;.format(3.1415926)</code></pre><p><strong>进制</strong><br>b、d、o、x分别是二进制、十进制、八进制、十六进制</p><pre><code>print &apos;{:b}&apos;.format(11)print &apos;{:d}&apos;.format(11)print &apos;{:o}&apos;.format(11)print &apos;{:x}&apos;.format(11)print &apos;{:#x}&apos;.format(11)print &apos;{:#X}&apos;.format(11)</code></pre><p><strong>千位分隔符</strong></p><pre><code>print &apos;{:,}&apos;.format(15700000000)</code></pre><p><strong><em>str的内建函数</em></strong><br>在最开始的时候，Python有一个专门的string模块，要使用string的方法要先import这个模块。从Python2.0开始， 为了方便使用，str类型添加了很多内建函数，这些函数可以实现跟string模块中函数相同的功能，也就是说，只要S是一个字符串对象就可以直接使用内建函数，而不用import。<br>对于字符串的格式化处理，也可以考虑使用str的其他内建函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(str)</span><br><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__</span><br><span class="line">format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getnewargs__&apos;, &apos;__get</span><br><span class="line">slice__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mo</span><br><span class="line">d__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;,</span><br><span class="line"> &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook</span><br><span class="line">__&apos;, &apos;_formatter_field_name_split&apos;, &apos;_formatter_parser&apos;, &apos;capitalize&apos;, &apos;center&apos;,</span><br><span class="line"> &apos;count&apos;, &apos;decode&apos;, &apos;encode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;index</span><br><span class="line">&apos;, &apos;isalnum&apos;, &apos;isalpha&apos;, &apos;isdigit&apos;, &apos;islower&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;,</span><br><span class="line">&apos;join&apos;, &apos;ljust&apos;, &apos;lower&apos;, &apos;lstrip&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;</span><br><span class="line">rjust&apos;, &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;</span><br><span class="line">strip&apos;, &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;]</span><br></pre></td></tr></table></figure><p>下面整理出来了一些常用的str类型的内建函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 小写 </span><br><span class="line">S.lower() </span><br><span class="line"># 大写 </span><br><span class="line">S.upper() </span><br><span class="line">#大小写互换 </span><br><span class="line">S.swapcase() </span><br><span class="line"># 首字母大写 </span><br><span class="line">S.capitalize() </span><br><span class="line"># 输出width个字符，S左对齐，不足部分用fillchar填充，默认的为空格。 </span><br><span class="line">S.ljust(width,[fillchar]) </span><br><span class="line"># 右对齐 </span><br><span class="line">S.rjust(width,[fillchar]) </span><br><span class="line"># 中间对齐 </span><br><span class="line">S.center(width, [fillchar]) </span><br><span class="line"># 返回S中出现substr的第一个字母的标号，如果S中没有substr则返回-1。start和end作用就相当于在S[start:end]中搜索 </span><br><span class="line">S.find(substr, [start, [end]]) </span><br><span class="line"># 返回S中最后出现的substr的第一个字母的标号，如果S中没有substr则返回-1，也就是说从右边算起的第一次出现的substr的首字母标号 </span><br><span class="line">S.rfind(substr, [start, [end]]) </span><br><span class="line"># 计算substr在S中出现的次数 </span><br><span class="line">S.count(substr, [start, [end]]) </span><br><span class="line">#把S中的oldstar替换为newstr，count为替换次数</span><br><span class="line">S.replace(oldstr, newstr, [count]) </span><br><span class="line"># 把S中前后chars中有的字符全部去掉，可以理解为把S前后chars替换为None </span><br><span class="line">S.strip([chars]) </span><br><span class="line">S.lstrip([chars]) </span><br><span class="line">S.rstrip([chars]) </span><br><span class="line"># 以sep为分隔符，把S分成一个list。maxsplit表示分割的次数。默认的分割符为空白字符 </span><br><span class="line">S.split([sep, [maxsplit]]) </span><br><span class="line"># 把seq代表的字符串序列，用S连接起来 </span><br><span class="line">S.join(seq)</span><br></pre></td></tr></table></figure><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>Python 数字数据类型用于存储数值。<br>数据类型是不允许改变的,这就意味着如果改变数字数据类型得值，将重新分配内存空间。<br>以下实例在变量赋值时 Number 对象将被创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = 1</span><br><span class="line">var2 = 10</span><br></pre></td></tr></table></figure><p>您也可以使用del语句删除一些数字对象的引用。<br>del语句的语法是：</p><blockquote><p>del var1[,var2[,var3[….,varN]]]]<br>您可以通过使用del语句删除单个或多个对象的引用，例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del var</span><br><span class="line">del var_a, var_b</span><br></pre></td></tr></table></figure><p>Python 支持三种不同的数值类型：<br>• <code>整型(Int)</code> - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 <code>Long 类型</code>使用，所以 Python3 没有 Python2 的 <code>Long</code> 类型。<br>• <code>浮点型(float)</code> - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）<br>• <code>复数( (complex))</code> - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。<br>我们可以使用十六进制和八进制来代表整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; number = 0xA0F # 十六进制</span><br><span class="line">&gt;&gt;&gt; number</span><br><span class="line">2575</span><br><span class="line">&gt;&gt;&gt; number=0o37 # 八进制</span><br><span class="line">&gt;&gt;&gt; number</span><br><span class="line">31</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">int</th><th style="text-align:left">float</th><th style="text-align:left">complex</th></tr></thead><tbody><tr><td style="text-align:left">10</td><td style="text-align:left">0.0</td><td style="text-align:left">3.14j</td></tr><tr><td style="text-align:left">100</td><td style="text-align:left">15.20</td><td style="text-align:left">45.j</td></tr><tr><td style="text-align:left">-786</td><td style="text-align:left">-21.9</td><td style="text-align:left">9.322e-36j</td></tr><tr><td style="text-align:left">080</td><td style="text-align:left">32.3+e18</td><td style="text-align:left">.876j</td></tr><tr><td style="text-align:left">-0490</td><td style="text-align:left">-90.</td><td style="text-align:left">-.6545+0J</td></tr><tr><td style="text-align:left">-0x260</td><td style="text-align:left">-32.54e100</td><td style="text-align:left">3e+26J</td></tr><tr><td style="text-align:left">0x69</td><td style="text-align:left">70.2-E12</td><td style="text-align:left">4.53e-7j</td></tr></tbody></table><p>• Python支持复数，复数由实数部分和虚数部分构成，可以用<code>a + bj</code>,或者<code>complex(a,b)</code>表示， 复数的实部a和虚部b都是浮点型。</p><p><strong><em>Python 数字类型转换</em></strong><br>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。<br>• <code>int(x)</code> 将x转换为一个整数。<br>• <code>float(x)</code> 将x转换到一个浮点数。<br>• <code>complex(x)</code> 将x转换到一个复数，实数部分为 x，虚数部分为 0。<br>• <code>complex(x, y)</code> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。<br>以下实例将浮点数变量 a 转换为整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 1.0</span><br><span class="line">&gt;&gt;&gt; int(a)</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong><em>Python 数字运算</em></strong><br>Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。<br>表达式的语法很直白： +, -, * 和 / 和其它语言（如Pascal或C）里一样。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 + 2</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; 50 - 5*6</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; (50 - 5*6) / 4</span><br><span class="line">5.0</span><br><span class="line">&gt;&gt;&gt; 8 / 5  # 总是返回一个浮点数</span><br><span class="line">1.6</span><br></pre></td></tr></table></figure><p>注意：在不同的机器上浮点运算的结果可能会不一样。<br>在整数除法中，除法（/）总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 // ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 17 / 3  # 整数除法返回浮点型</span><br><span class="line">5.666666666666667</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; 17 // 3  # 整数除法返回向下取整后的结果</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; 17 % 3  # ％操作符返回除法的余数</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 5 * 3 + 2 </span><br><span class="line">17</span><br></pre></td></tr></table></figure><p>等号（=）用于给变量赋值。赋值之后，除了下一个提示符，解释器不会显示任何结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; width = 20</span><br><span class="line">&gt;&gt;&gt; height = 5*9</span><br><span class="line">&gt;&gt;&gt; width * height</span><br><span class="line">900</span><br><span class="line">Python 可以使用 ** 操作来进行幂运算：</span><br><span class="line">&gt;&gt;&gt; 5 ** 2  # 5 的平方</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; 2 ** 7  # 2的7次方</span><br><span class="line">128</span><br></pre></td></tr></table></figure><p>变量在使用前必须先”定义”（即赋予变量一个值），否则会出现错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n   # 尝试访问一个未定义的变量</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &apos;n&apos; is not defined</span><br></pre></td></tr></table></figure><p>不同类型的数混合运算时会将整数转换为浮点数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 * 3.75 / 1.5</span><br><span class="line">7.5</span><br><span class="line">&gt;&gt;&gt; 7.0 / 2</span><br><span class="line">3.5</span><br></pre></td></tr></table></figure><p>在交互模式中，最后被输出的表达式结果被赋值给变量 _ 。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tax = 12.5 / 100</span><br><span class="line">&gt;&gt;&gt; price = 100.50</span><br><span class="line">&gt;&gt;&gt; price * tax</span><br><span class="line">12.5625</span><br><span class="line">&gt;&gt;&gt; price + _</span><br><span class="line">113.0625</span><br><span class="line">&gt;&gt;&gt; round(_, 2)</span><br><span class="line">113.06</span><br></pre></td></tr></table></figure><p><code>此处， _ 变量应被用户视为只读变量。</code></p><p><strong><em>数学函数</em></strong></p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">返回值 ( 描述 )</th></tr></thead><tbody><tr><td style="text-align:left">abs(x)</td><td style="text-align:left">返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td style="text-align:left">ceil(x)</td><td style="text-align:left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td style="text-align:left">cmp(x, y)</td><td style="text-align:left">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃 。使用 使用 (x&gt;y)-(x&lt;y) 替换。</td></tr><tr><td style="text-align:left">exp(x)</td><td style="text-align:left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td style="text-align:left">fabs(x)</td><td style="text-align:left">返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td style="text-align:left">floor(x)</td><td style="text-align:left">返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td style="text-align:left">log(x)</td><td style="text-align:left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td style="text-align:left">log10(x)</td><td style="text-align:left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td style="text-align:left">max(x1, x2,…)</td><td style="text-align:left">返回给定参数的最大值，参数可以为序列。</td></tr><tr><td style="text-align:left">min(x1, x2,…)</td><td style="text-align:left">返回给定参数的最小值，参数可以为序列。</td></tr><tr><td style="text-align:left">modf(x)</td><td style="text-align:left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td style="text-align:left">pow(x, y)</td><td style="text-align:left">x**y 运算后的值。</td></tr><tr><td style="text-align:left">round(x [,n])</td><td style="text-align:left">返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td></tr><tr><td style="text-align:left">sqrt(x)</td><td style="text-align:left">返回数字x的平方根，数字可以为负数，返回类型为实数，如math.sqrt(4)返回 2+0j</td></tr></tbody></table><p><strong><em>随机数函数</em></strong><br>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。<br>Python包含以下常用随机数函数：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">choice(seq)</td><td style="text-align:left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td style="text-align:left">randrange ([start,] stop [,step])</td><td style="text-align:left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1</td></tr><tr><td style="text-align:left">random()</td><td style="text-align:left">随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td style="text-align:left">seed([x])</td><td style="text-align:left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td style="text-align:left">shuffle(lst)</td><td style="text-align:left">将序列的所有元素随机排序</td></tr><tr><td style="text-align:left">uniform(x, y)</td><td style="text-align:left">随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table><p><strong><em>三角函数</em></strong><br>Python包括以下三角函数：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">acos(x)</td><td style="text-align:left">返回x的反余弦弧度值。</td></tr><tr><td style="text-align:left">asin(x)</td><td style="text-align:left">返回x的反正弦弧度值。</td></tr><tr><td style="text-align:left">atan(x)</td><td style="text-align:left">返回x的反正切弧度值。</td></tr><tr><td style="text-align:left">atan2(y, x)</td><td style="text-align:left">返回给定的 X 及 Y 坐标值的反正切值。</td></tr><tr><td style="text-align:left">cos(x)</td><td style="text-align:left">返回x的弧度的余弦值。</td></tr><tr><td style="text-align:left">hypot(x, y)</td><td style="text-align:left">返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td></tr><tr><td style="text-align:left">sin(x)</td><td style="text-align:left">返回的x弧度的正弦值。</td></tr><tr><td style="text-align:left">tan(x)</td><td style="text-align:left">返回x弧度的正切值。</td></tr><tr><td style="text-align:left">degrees(x)</td><td style="text-align:left">将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td></tr><tr><td style="text-align:left">radians(x)</td><td style="text-align:left">将角度转换为弧度</td></tr></tbody></table><p><strong><em>数学常量</em></strong></p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">pi</td><td style="text-align:left">数学常量 pi（圆周率，一般以π来表示）</td></tr><tr><td style="text-align:left">e</td><td style="text-align:left">数学常量 e，e即自然常数（自然常数）。</td></tr></tbody></table><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。<br>Python有6个序列的内置类型，但最常见的是列表和元组。<br>序列都可以进行的操作包括索引，切片，加，乘，检查成员。<br>此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。<br>列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。<br>列表的数据项不需要具有相同的类型<br>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [&apos;Google&apos;, &apos;BAIDU&apos;, 1997, 2000];</span><br><span class="line">list2 = [1, 2, 3, 4, 5 ];</span><br><span class="line">list3 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];</span><br></pre></td></tr></table></figure><p>与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。</p><p><strong>访问列表中的值</strong><br>使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">list1 = [&apos;Google&apos;, &apos;BAIDU&apos;, 1997, 2000];</span><br><span class="line">list2 = [1, 2, 3, 4, 5, 6, 7 ];</span><br><span class="line">print (&quot;list1[0]: &quot;, list1[0])</span><br><span class="line">print (&quot;list2[1:5]: &quot;, list2[1:5])</span><br></pre></td></tr></table></figure><p>运行实例 »<br>以上实例输出结果：</p><blockquote><p>list1[0]:  Google<br>list2[1:5]:  [2, 3, 4, 5]</p></blockquote><p><strong>更新列表</strong><br>你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">list = [&apos;Google&apos;, &apos;BAIDU&apos;, 1997, 2000]</span><br><span class="line">print (&quot;第三个元素为 : &quot;, list[2])</span><br><span class="line">list[2] = 2001</span><br><span class="line">print (&quot;更新后的第三个元素为 : &quot;, list[2])</span><br></pre></td></tr></table></figure><p>注意：我们会在接下来的章节讨论append()方法的使用<br>以上实例输出结果：</p><blockquote><p>第三个元素为 :  1997<br>更新后的第三个元素为 :  2001</p></blockquote><p><strong>删除列表元素</strong><br>可以使用 del 语句来删除列表的的元素，如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">list = [&apos;Google&apos;, &apos;BAIDU&apos;, 1997, 2000]</span><br><span class="line">print (list)</span><br><span class="line">del list[2]</span><br><span class="line">print (&quot;删除第三个元素 : &quot;, list)</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><blockquote><p>删除第三个元素 :  [‘Google’, ‘BAIDU’, 2000]<br>注意：我们会在接下来的章节讨论remove()方法的使用</p></blockquote><p><strong>Python列表脚本操作符</strong><br>列表对 + 和 <em> 的操作符与字符串相似。+ 号用于组合列表，</em> 号用于重复列表。<br>如下所示：</p><table><thead><tr><th style="text-align:left">Python 表达式</th><th style="text-align:left">结果</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">len([1, 2, 3])</td><td style="text-align:left">3</td><td style="text-align:left">长度</td></tr><tr><td style="text-align:left">[1, 2, 3] + [4, 5, 6]</td><td style="text-align:left">[1, 2, 3, 4, 5, 6]</td><td style="text-align:left">组合</td></tr><tr><td style="text-align:left">[‘Hi!’] * 4</td><td style="text-align:left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td style="text-align:left">重复</td></tr><tr><td style="text-align:left">3 in [1, 2, 3]</td><td style="text-align:left">True</td><td style="text-align:left">元素是否存在于列表中</td></tr><tr><td style="text-align:left">for x in [1, 2, 3]: print x,</td><td style="text-align:left">1 2 3</td><td style="text-align:left">迭代</td></tr></tbody></table><p><strong>Python列表截取与拼接</strong><br>Python的列表截取与字符串操作类型，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L=[&apos;Google&apos;, &apos;BAIDU&apos;, &apos;Taobao&apos;]</span><br><span class="line">&gt;&gt;&gt; L=[&apos;Google&apos;, &apos;baidu&apos;, &apos;Taobao&apos;]</span><br><span class="line">&gt;&gt;&gt; L[2]</span><br><span class="line">&apos;Taobao&apos;</span><br><span class="line">&gt;&gt;&gt; L[-2]</span><br><span class="line">&apos;baidu&apos;</span><br><span class="line">&gt;&gt;&gt; L[1:]</span><br><span class="line">[&apos;baidu&apos;, &apos;Taobao&apos;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><strong>列表还支持拼接操作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squares = [1, 4, 9, 16, 25]</span><br><span class="line">&gt;&gt;&gt; squares + [36, 49, 64, 81, 100]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><p><strong>嵌套列表</strong><br>使用嵌套列表即在列表里创建其它列表，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">&gt;&gt;&gt; n = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; x = [a, n]</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1, 2, 3]]</span><br><span class="line">&gt;&gt;&gt; x[0]</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">&gt;&gt;&gt; x[0][1]</span><br><span class="line">&apos;b&apos;</span><br></pre></td></tr></table></figure><p><strong>Python列表函数&amp;方法</strong><br>Python包含以下函数:</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数</th><th style="text-align:left">返回值</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">len(list)</td><td style="text-align:left">列表元素个数</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">max(list)</td><td style="text-align:left">返回列表元素最大值</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">min(list)</td><td style="text-align:left">返回列表元素最小值</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">list(seq)</td><td style="text-align:left">将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法:</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">list.append(obj)</td><td style="text-align:left">在列表末尾添加新的对象</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">list.count(obj)</td><td style="text-align:left">统计某个元素在列表中出现的次数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">list.extend(seq)</td><td style="text-align:left">在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">list.index(obj)</td><td style="text-align:left">从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">list.insert(index, obj)</td><td style="text-align:left">将对象插入列表</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">list.pop(obj=list[-1])</td><td style="text-align:left">移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">list.remove(obj)</td><td style="text-align:left">移除列表中某个值的第一个匹配项</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">list.reverse()</td><td style="text-align:left">反向列表中元素</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">list.sort([func])</td><td style="text-align:left">对原列表进行排序</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">list.clear()</td><td style="text-align:left">清空列表</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">list.copy()</td><td style="text-align:left">复制列表</td></tr></tbody></table><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。<br>元组使用小括号，列表使用方括号。<br>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。<br>如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (&apos;Google&apos;, &apos;baidu&apos;, 1997, 2000);</span><br><span class="line">tup2 = (1, 2, 3, 4, 5 );</span><br><span class="line">tup3 = &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;;</span><br></pre></td></tr></table></figure><p><strong><em>创建空元组</em></strong></p><blockquote><p>tup1 = ();<br>元组中只包含一个元素时，需要在元素后面添加逗号</p></blockquote><blockquote><p>tup1 = (50,);<br>元组与字符串类似，下标索引从0开始，可以进行截取，组合等。</p></blockquote><p><strong><em>访问元组</em></strong><br>元组可以使用下标索引来访问元组中的值，如下实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">tup1 = (&apos;Google&apos;, &apos;baidu&apos;, 1997, 2000)</span><br><span class="line">tup2 = (1, 2, 3, 4, 5, 6, 7 )</span><br><span class="line">print (&quot;tup1[0]: &quot;, tup1[0])</span><br><span class="line">print (&quot;tup2[1:5]: &quot;, tup2[1:5])</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1[0]:  Google</span><br><span class="line">tup2[1:5]:  (2, 3, 4, 5)</span><br></pre></td></tr></table></figure><p><strong><em>修改元组</em></strong><br>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">tup1 = (12, 34.56);</span><br><span class="line">tup2 = (&apos;abc&apos;, &apos;xyz&apos;)</span><br><span class="line"># 以下修改元组元素操作是非法的。</span><br><span class="line"># tup1[0] = 100</span><br><span class="line"># 创建一个新的元组</span><br><span class="line">tup3 = tup1 + tup2;</span><br><span class="line">print (tup3)</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><blockquote><p>(12, 34.56, ‘abc’, ‘xyz’)</p></blockquote><p><strong><em>删除元组</em></strong><br>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">tup = (&apos;Google&apos;, &apos;baidu&apos;, 1997, 2000)</span><br><span class="line">print (tup)</span><br><span class="line">del tup;</span><br><span class="line">print (&quot;删除后的元组 tup : &quot;)</span><br><span class="line">print (tup)</span><br></pre></td></tr></table></figure><p>以上实例元组被删除后，输出变量会有异常信息，输出如下所示：<br>删除后的元组 tup : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    print (tup)</span><br><span class="line">NameError: name &apos;tup&apos; is not defined</span><br></pre></td></tr></table></figure><p><strong><em>元组运算符</em></strong><br>与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p><table><thead><tr><th style="text-align:left">Python 表达式</th><th style="text-align:left">结果</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">len((1, 2, 3))</td><td style="text-align:left">3</td><td style="text-align:left">计算元素个数</td></tr><tr><td style="text-align:left">(1, 2, 3) + (4, 5, 6)</td><td style="text-align:left">(1, 2, 3, 4, 5, 6)</td><td style="text-align:left">连接</td></tr><tr><td style="text-align:left">(‘Hi!’,) * 4</td><td style="text-align:left">(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td><td style="text-align:left">复制</td></tr><tr><td style="text-align:left">3 in (1, 2, 3)</td><td style="text-align:left">True</td><td style="text-align:left">元素是否存在</td></tr><tr><td style="text-align:left">for x in (1, 2, 3): print x,</td><td style="text-align:left">1 2 3</td><td style="text-align:left">迭代</td></tr></tbody></table><p><strong><em>元组索引，截取</em></strong><br>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：<br>运行实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = (&apos;Google&apos;, &apos;Taobao&apos;, &apos;baidu&apos;)</span><br><span class="line">&gt;&gt;&gt; L[2]</span><br><span class="line">&apos;BAIDU&apos;</span><br><span class="line">&gt;&gt;&gt; L[-2]</span><br><span class="line">&apos;Taobao&apos;</span><br><span class="line">&gt;&gt;&gt; L[1:]</span><br><span class="line">(&apos;Taobao&apos;, &apos;baidu&apos;)</span><br></pre></td></tr></table></figure><p><strong><em>元组内置函数</em></strong><br>Python元组包含了以下内置函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">计算元组元素个数。len(tuple)</span><br><span class="line">&gt;&gt;&gt; tuple1 = (&apos;Google&apos;, &apos;baidu&apos;, &apos;Taobao&apos;)</span><br><span class="line">&gt;&gt;&gt; len(tuple1)</span><br><span class="line">3</span><br><span class="line">计算元组元素的最大值max(tuple)</span><br><span class="line">&gt;&gt;&gt; tuple2 = (&apos;5&apos;, &apos;4&apos;, &apos;8&apos;)</span><br><span class="line">&gt;&gt;&gt; max(tuple2)</span><br><span class="line">&apos;8&apos;</span><br><span class="line">返回元组中元素最小值。min(tuple)</span><br><span class="line">&gt;&gt;&gt; tuple2 = (&apos;5&apos;, &apos;4&apos;, &apos;8&apos;)</span><br><span class="line">&gt;&gt;&gt; min(tuple2)</span><br><span class="line">&apos;4&apos;</span><br><span class="line">将列表转换为元组。tuple(seq)</span><br><span class="line">&gt;&gt;&gt; list1= [&apos;Google&apos;, &apos;Taobao&apos;, &apos;souhu&apos;, &apos;Baidu&apos;]</span><br><span class="line">&gt;&gt;&gt; tuple1=tuple(list1)</span><br><span class="line">&gt;&gt;&gt; tuple1</span><br><span class="line">(&apos;Google&apos;, &apos;Taobao&apos;, &apos;souhu&apos;, &apos;Baidu&apos;)</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>可变集合set<br>集合set是Python中一种基本数据类型，它分为可变集合（set）和不可变集合（frozenset）两种。类似于其他语言，集合是一个无序不重复元素集，包括创建集合set、向集合中添加元素、删除集合中的元素、求集合的交集、并集、差集等操作。下面就让我们一一来学习集合的这些知识吧。<br>set集合类需要的参数必须是迭代器类型的，如：序列、字典等，然后转换成无序不重复的元素集。由于集合是不重复的，所以可以对字符串、列表、元组进行去重操作。<br><strong>创建空集合</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l =  set()</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">set([])</span><br><span class="line">&gt;&gt;&gt; ss = set([])</span><br><span class="line">&gt;&gt;&gt; ss</span><br><span class="line">set([])</span><br><span class="line">&gt;&gt;&gt; st = set(())</span><br><span class="line">&gt;&gt;&gt; st</span><br></pre></td></tr></table></figure><p><strong>创建非空集合</strong><br>集合中set括号中需要的参数的数据类型有：序列（包括字符串、列表、元组），字典或者是另一个集合，但是不能是数值类型，如int类型。</p><p><code>字符串做参数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set(&apos;createSet&apos;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">set([&apos;a&apos;, &apos;c&apos;, &apos;e&apos;, &apos;S&apos;, &apos;r&apos;, &apos;t&apos;])</span><br></pre></td></tr></table></figure><p><code>list做参数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1,2,3,1,3,4,5])</span><br><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure><p><code>元组做参数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s2 = set((1,2,3,4,1))</span><br><span class="line">&gt;&gt;&gt; s2</span><br><span class="line">set([1, 2, 3, 4])</span><br></pre></td></tr></table></figure><p><code>字典做参数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s3 = set(&#123;1:2,2:3&#125;)</span><br><span class="line">&gt;&gt;&gt; s3</span><br><span class="line">set([1, 2])</span><br></pre></td></tr></table></figure><p>字典转set集合，需要注意的是，只取了字典的key，相当于将字典中的dict.keys()列表转成set集合。</p><p><code>set集合做参数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; ss = set(s1)</span><br><span class="line">&gt;&gt;&gt; ss</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure><p><strong>集合添加</strong><br>集合的添加有两种方式，分别是add和update。但是它们在添加元素时是由区别的：<br><code>add()方法</code><br>是把要传入的元素作为一个整体添加到集合中，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sTest = set(&apos;one&apos;)</span><br><span class="line">&gt;&gt;&gt; sTest</span><br><span class="line">set([&apos;e&apos;, &apos;o&apos;, &apos;n&apos;])</span><br><span class="line">#添加一个&apos;two&apos;元素，并查看结果</span><br><span class="line">&gt;&gt;&gt; sTest.add(&apos;two&apos;)</span><br><span class="line">&gt;&gt;&gt; sTest</span><br><span class="line">set([&apos;e&apos;, &apos;two&apos;, &apos;o&apos;, &apos;n&apos;])</span><br></pre></td></tr></table></figure><p><code>update()方法</code><br>是把要传入的元素拆分成单个字符，存于集合中，并去掉重复的字符。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sTest</span><br><span class="line">set([&apos;e&apos;, &apos;two&apos;, &apos;o&apos;, &apos;n&apos;])</span><br><span class="line">&gt;&gt;&gt; sTest.update(&apos;123&apos;)</span><br><span class="line">&gt;&gt;&gt; sTest</span><br><span class="line">set([&apos;e&apos;, &apos;two&apos;, &apos;o&apos;, &apos;n&apos;, &apos;1&apos;, &apos;3&apos;, &apos;2&apos;])</span><br></pre></td></tr></table></figure><p><code>集合删除</code><br>集合的删除操作使用的方法跟列表是一样的，使用的也是remove方法。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sTest</span><br><span class="line">set([&apos;e&apos;, &apos;two&apos;, &apos;o&apos;, &apos;n&apos;, &apos;1&apos;, &apos;3&apos;, &apos;2&apos;])</span><br><span class="line">#删除集合中的元素&apos;e&apos;</span><br><span class="line">&gt;&gt;&gt; sTest.remove(&apos;e&apos;)</span><br><span class="line">&gt;&gt;&gt; sTest</span><br><span class="line">set([&apos;two&apos;, &apos;o&apos;, &apos;n&apos;, &apos;1&apos;, &apos;3&apos;, &apos;2&apos;])</span><br></pre></td></tr></table></figure><p><code>集合的遍历</code><br>集合的遍历跟序列的遍历方法完全一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; st = set([1,2,&apos;a&apos;,&apos;c&apos;,4,&apos;d&apos;])</span><br><span class="line">&gt;&gt;&gt; for i in st :</span><br><span class="line">...   print i,</span><br><span class="line">...</span><br><span class="line">a 1 2 4 d c</span><br></pre></td></tr></table></figure><p><code>另一种遍历方式：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for idx, i in enumerate(st) :</span><br><span class="line">...   print idx, i</span><br></pre></td></tr></table></figure><p>变量idx表示集合中元素i的索引。</p><p><strong>集合与序列间转换</strong><br>集合可以和序列之间的转换跟序列之间互转是一样的，唯一不同的就是序列转成集合后，重复的元素被去掉了。<br><em>集合与字符串转换</em><br><code>字符串转集合</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set(&apos;python&apos;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">set([&apos;h&apos;, &apos;o&apos;, &apos;n&apos;, &apos;p&apos;, &apos;t&apos;, &apos;y&apos;])</span><br></pre></td></tr></table></figure><p><code>集合转字符串</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(s)</span><br><span class="line">&quot;set([&apos;h&apos;, &apos;o&apos;, &apos;n&apos;, &apos;p&apos;, &apos;t&apos;, &apos;y&apos;])&quot;</span><br></pre></td></tr></table></figure><p>需要注意的是，使用str()函数直接对集合转字符串，结果是集合的字符串形式。<br>我们也可以使用字符串的连接函数join()函数，进行集合转字符串，但是这样得到的字符串种的元素也是无序的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set(&apos;python&apos;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">set([&apos;h&apos;, &apos;o&apos;, &apos;n&apos;, &apos;p&apos;, &apos;t&apos;, &apos;y&apos;])</span><br><span class="line">&gt;&gt;&gt; &apos;&apos;.join(s)</span><br><span class="line">&apos;honpty&apos;</span><br></pre></td></tr></table></figure><p><em>集合与list转换</em><br><code>list转set</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list1 = [1,2,3,3,4,5]</span><br><span class="line">&gt;&gt;&gt; sList = set(list1)</span><br><span class="line">&gt;&gt;&gt; sList</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure><p><code>set转list</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list2 = list(sList)</span><br><span class="line">&gt;&gt;&gt; list2</span><br><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>集合转list结果是得到一个去重后的list，这种去重比用之前讲过的利用字典key唯一和利用list自身特定去重的方法都要简单快捷。<br><em>集合转元组</em><br><code>tuple转set</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tup = (1,2,3,3,45,6)</span><br><span class="line">&gt;&gt;&gt; sTup = set(tup)</span><br><span class="line">&gt;&gt;&gt; sTup</span><br><span class="line">set([1, 2, 3, 45, 6])</span><br></pre></td></tr></table></figure><p><code>set转tuple</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tup1 = tuple(sTup)</span><br><span class="line">&gt;&gt;&gt; tup1</span><br><span class="line">(1, 2, 3, 45, 6)</span><br></pre></td></tr></table></figure><p>set转tuple后，得到的元组也是去重后的元组。</p><p><em>集合其他常用方法</em><br><code>pop()方法</code></p><p>函数原型：<br>s.pop()<br>参数说明：<br>s：为set类型的变量<br>函数作用：<br>删除并返回set类型的s中的一个不确定的元素，如果为空引发KeyError错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sList</span><br><span class="line">set([2, 3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; sList.pop()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; sList</span><br><span class="line">set([3, 4, 5])</span><br><span class="line">6.3 clear()</span><br></pre></td></tr></table></figure><p><code>s.clear()</code><br>参数说明：<br>s：set类型的变量<br>函数作用：<br>清空s集合中的所有元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sList</span><br><span class="line">set([3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; sList.clear()</span><br><span class="line">&gt;&gt;&gt; sList</span><br><span class="line">set([])</span><br></pre></td></tr></table></figure><p><em>集合的一些操作符</em><br>既然是集合，那就会遵循集合的一些操作方法，如求交集、并集、差集等。<br><code>交集</code><br>python中求集合的交集使用的符号是“&amp;”，返回连个集合的共同元素的集合，即集合的交集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; st1 = set(&apos;python&apos;)</span><br><span class="line">&gt;&gt;&gt; st1</span><br><span class="line">set([&apos;h&apos;, &apos;o&apos;, &apos;n&apos;, &apos;p&apos;, &apos;t&apos;, &apos;y&apos;])</span><br><span class="line">&gt;&gt;&gt; st2 = set(&apos;htc&apos;)</span><br><span class="line">&gt;&gt;&gt; st2</span><br><span class="line">set([&apos;h&apos;, &apos;c&apos;, &apos;t&apos;])</span><br><span class="line">&gt;&gt;&gt; st1 &amp; st2</span><br><span class="line">set([&apos;h&apos;, &apos;t&apos;])</span><br></pre></td></tr></table></figure><p><code>并集（合集）</code><br>Python中求集合的并集用的是符号“|”，返回的是两个集合所有的并去掉重复的元素的集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; st1</span><br><span class="line">set([&apos;h&apos;, &apos;o&apos;, &apos;n&apos;, &apos;p&apos;, &apos;t&apos;, &apos;y&apos;])</span><br><span class="line">&gt;&gt;&gt; st3 = set(&apos;two&apos;)</span><br><span class="line">&gt;&gt;&gt; st3</span><br><span class="line">set([&apos;o&apos;, &apos;t&apos;, &apos;w&apos;])</span><br><span class="line">&gt;&gt;&gt; st1 | st3</span><br><span class="line">set([&apos;p&apos;, &apos;t&apos;, &apos;w&apos;, &apos;y&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;])</span><br></pre></td></tr></table></figure><p><code>差集</code><br>Python中差集使用的符号是减号“-”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; st1</span><br><span class="line">set([&apos;1&apos;, &apos;3&apos;, &apos;2&apos;, &apos;5&apos;, &apos;4&apos;, &apos;7&apos;, &apos;6&apos;])</span><br><span class="line">&gt;&gt;&gt; st2 = set(&apos;4589&apos;)</span><br><span class="line">&gt;&gt;&gt; st2</span><br><span class="line">set([&apos;9&apos;, &apos;8&apos;, &apos;5&apos;, &apos;4&apos;])</span><br><span class="line">&gt;&gt;&gt; st1 - st2</span><br><span class="line">set([&apos;1&apos;, &apos;3&apos;, &apos;2&apos;, &apos;7&apos;, &apos;6&apos;])</span><br></pre></td></tr></table></figure><p>返回的结果是在集合st1中但不在集合st2中的元素的集合。</p><p><code>集合的不同</code><br>查看两个集合的不同之处，使用的difference函数，等价于差集。如： </p><blockquote><p>s1.difference(s3)<br>这种不同指的是集合s3相对于集合s1，不同的地方，也就是所有在集合s1中，而不再集合s2中的的元素组成的新集合。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; s2</span><br><span class="line">set([1, 2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1.difference(s2)</span><br><span class="line">set([5])</span><br><span class="line">&gt;&gt;&gt; s3</span><br><span class="line">set([&apos;1&apos;, &apos;8&apos;, &apos;9&apos;, &apos;5&apos;])</span><br><span class="line">&gt;&gt;&gt; s1.difference(s3)</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure><p><code>集合的范围判断</code><br>集合可以使用大于（&gt;）、小于（&lt;）、大于等于（&gt;=）、小于等于（&lt;=）、等于（==）、不等于（！=）来判断某个集合是否完全包含于另一个集合，也可以使用子父集判断函数。<br>定义三个集合s1，s2，s3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; s2</span><br><span class="line">set([1, 2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s3</span><br><span class="line">set([&apos;1&apos;, &apos;8&apos;, &apos;9&apos;, &apos;5&apos;])</span><br></pre></td></tr></table></figure><p><code>大于（&gt;）或大于等于（&gt;=）</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 &gt; s2</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; s1 &gt; s3</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s1 &gt;= s2</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>表示左边集合是否完全包含右边集合，如集合s1是否完全包含集合s2。<br><code>小于（&lt;）或 小于等于（&lt;=）</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s2 &lt; s1</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; s1 &lt; s3</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s3 &lt; s1</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>表示左边的集合是否完全包含于右边的集合，如集合s1是否完全包含于集合s2。<br><code>等于（==）、不等于（！=）</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 == s2</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s2 == s3</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s1 != s2</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>判断两个集合是否完全相同。</p><p><code>集合的成员运算符</code><br>集合里也可以使用成员运算符，in和not in，判断某个对象是否是集合中的成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; 1 in s1</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 6 in s1</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 2 not in s1</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 6 not in s1</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p><code>集合拷贝</code><br>集合的拷贝函数是：copy()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; sc = s1.copy()</span><br><span class="line">&gt;&gt;&gt; sc</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure><p>将集合s1拷贝一份并赋给变量sc。</p><p><code>求集合长度</code><br>跟序列一样，求集合的长度也是使用len()函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; len(s1)</span><br></pre></td></tr></table></figure><p><code>求集合的关系</code><br>a.issuperset(b)<br>判断集合a是否是b的父集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s2</span><br><span class="line">set([1, 2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; s1.issuperset(s2)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>判断s1集合是否是集合s2的父集，是返回True，否则返回False。</p><p>b.issubset(a)<br>判断b是否是a的子集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s2</span><br><span class="line">set([1, 2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">set([1, 2, 3, 4, 5])</span><br><span class="line">&gt;&gt;&gt; s1.issubset(s2)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s2.issubset(s1)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>判断s2集合是否是集合s1的子集，是返回True，否则返回False。</p><p><code>不可变集合frozenset</code><br>Python中还有一种不可改变的集合，那就是frozenset，不像set集合，可以增加删除集合中的元素，该集合中的内容是不可改变的，类似于字符串、元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = frozenset()</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">frozenset([])</span><br><span class="line">&gt;&gt;&gt; f = frozenset(&apos;asdf&apos;)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">frozenset([&apos;a&apos;, &apos;s&apos;, &apos;d&apos;, &apos;f&apos;])</span><br><span class="line">&gt;&gt;&gt; f = frozenset([1,2,3,4])</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">frozenset([1, 2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; f = frozenset((1,2,3,4))</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">frozenset([1, 2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; f = frozenset(&#123;1:2, &apos;a&apos;:2, &apos;c&apos;:3&#125;)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">frozenset([&apos;a&apos;, 1, &apos;c&apos;])</span><br></pre></td></tr></table></figure><p>如果试图改变不可变集合中的元素，就会报AttributeError错误。<br>不可变集合，除了内容不能更改外，其他功能及操作跟可变集合set一样。<br>注意：<br>无论是可变集合还是不可变集合，参数除了支持字符、数字、还可以是汉字（要注意编码的问题），类等。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。<br>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ,格式如下所示：</p><blockquote><p>d = {key1 : value1, key2 : value2 }</p></blockquote><p><code>键必须是唯一的，但值则不必。</code><br><code>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</code><br>一个简单的字典实例：</p><blockquote><p>dict = {‘Alice’: ‘2341’, ‘Beth’: ‘9102’, ‘Cecil’: ‘3258’}<br>也可如此创建字典：<br>dict1 = { ‘abc’: 456 };<br>dict2 = { ‘abc’: 123, 98.6: 37 };</p></blockquote><p><strong>访问字典里的值</strong><br>把相应的键放入熟悉的方括弧，如下实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">dict = &#123;&apos;Name&apos;: &apos;BAIDU&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;</span><br><span class="line">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])</span><br><span class="line">print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict[&apos;Name&apos;]:  BAIDU</span><br><span class="line">dict[&apos;Age&apos;]:  7</span><br></pre></td></tr></table></figure><p>如果用字典里没有的键访问数据，会输出错误如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">dict = &#123;&apos;Name&apos;: &apos;BAIDU&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;;</span><br><span class="line"> </span><br><span class="line">print (&quot;dict[&apos;Alice&apos;]: &quot;, dict[&apos;Alice&apos;])</span><br><span class="line">以上实例输出结果：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    print (&quot;dict[&apos;Alice&apos;]: &quot;, dict[&apos;Alice&apos;])</span><br><span class="line">KeyError: &apos;Alice&apos;</span><br></pre></td></tr></table></figure><p><strong>修改字典</strong><br>向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">dict = &#123;&apos;Name&apos;: &apos;baidu&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;</span><br><span class="line">dict[&apos;Age&apos;] = 8;               # 更新 Age</span><br><span class="line">dict[&apos;School&apos;] = &quot;宝安中学&quot;  # 添加信息</span><br><span class="line">print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])</span><br><span class="line">print (&quot;dict[&apos;School&apos;]: &quot;, dict[&apos;School&apos;])</span><br><span class="line">以上实例输出结果：</span><br><span class="line">dict[&apos;Age&apos;]:  8</span><br><span class="line">dict[&apos;School&apos;]:  宝安中学</span><br></pre></td></tr></table></figure><p><strong>删除字典元素</strong><br>能删单一的元素也能清空字典，清空只需一项操作。<br>显示删除一个字典用del命令，如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">dict = &#123;&apos;Name&apos;: &apos;BAIDU&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;</span><br><span class="line">del dict[&apos;Name&apos;] # 删除键 &apos;Name&apos;</span><br><span class="line">dict.clear()     # 删除字典</span><br><span class="line">del dict         # 删除字典</span><br><span class="line">print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])</span><br><span class="line">print (&quot;dict[&apos;School&apos;]: &quot;, dict[&apos;School&apos;])</span><br><span class="line">但这会引发一个异常，因为用执行 del 操作后字典不再存在：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 9, in &lt;module&gt;</span><br><span class="line">    print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])</span><br><span class="line">TypeError: &apos;type&apos; object is not subscriptable</span><br></pre></td></tr></table></figure><p>注：del() 方法后面也会讨论。<br><strong>字典键的特性`</strong><br>字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。<br>两个重要的点需要记住：<br><code>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">dict = &#123;&apos;Name&apos;: &apos;BAIDU&apos;, &apos;Age&apos;: 7, &apos;Name&apos;: &apos;Peter&apos;&#125;</span><br><span class="line">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])</span><br><span class="line">以上实例输出结果：</span><br><span class="line">dict[&apos;Name&apos;]:  Peter`</span><br></pre></td></tr></table></figure><p><code>2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">dict = &#123;[&apos;Name&apos;]: &apos;BAIDU&apos;, &apos;Age&apos;: 7&#125;</span><br><span class="line">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])</span><br><span class="line">以上实例输出结果：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    dict = &#123;[&apos;Name&apos;]: &apos;BAIDU&apos;, &apos;Age&apos;: 7&#125;</span><br><span class="line">TypeError: unhashable type: &apos;list&apos;</span><br></pre></td></tr></table></figure><p><strong>字典内置函数&amp;方法</strong><br>Python字典包含了以下内置函数：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数及描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">计算字典元素个数，即键的总数。</td><td style="text-align:left">len(dict)    &gt;&gt;&gt; dict = {‘Name’: ‘baidu’, ‘Age’: 7, ‘Class’: ‘First’} &gt;&gt;&gt; len(dict)  3</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">输出字典，以可打印的字符串表示。</td><td style="text-align:left">str(dict)    &gt;&gt;&gt; dict = {‘Name’: ‘baidu’, ‘Age’: 7, ‘Class’: ‘First’}&gt;&gt;&gt; str(dict)   “{‘Name’: ‘baidu’, ‘Class’: ‘First’, ‘Age’: 7}”</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">返回输入的变量类型，如果变量是字典就返回字典类型。</td><td style="text-align:left">type(variable)&gt;&gt;&gt; dict = {‘Name’: ‘baidu’, ‘Age’: 7, ‘Class’: ‘First’}&gt;&gt;&gt; type(dict)<class 'dict'=""></class></td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">radiansdict.clear()删除字典内所有元素</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">radiansdict.copy()返回一个字典的浅复制</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">radiansdict.fromkeys()创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">radiansdict.get(key, default=None)返回指定键的值，如果值不在字典中返回default值    </td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">key in dict如果键在字典dict里返回true，否则返回false</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">radiansdict.items()以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">radiansdict.keys()以列表返回一个字典所有的键</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">radiansdict.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">radiansdict.update(dict2)把字典dict2的键/值对更新到dict里</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">radiansdict.values()以列表返回字典中的所有值</td></tr></tbody></table><h1 id="Python杂项"><a href="#Python杂项" class="headerlink" title="Python杂项"></a>Python杂项</h1><h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><ol><li><strong>迭代器</strong><br>迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退，不过这也没什么，因为人们很少在迭代途中往后退。另外，迭代器的一大优点是不要求事先准备好整个迭代过程中所有的元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合，比如几个G的文件<br><code>特点：</code><br>访问者不需要关心迭代器内部的结构，仅需通过next()方法不断去取下一个内容<br>不能随机访问集合中的某个值 ，只能从头到尾依次访问<br>访问到一半时不能往回退<br>便于循环比较大的数据集合，节省内存</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = iter([1,2,3,4,5])</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;list_iterator object at 0x101402630&gt;</span><br><span class="line">&gt;&gt;&gt; a.__next__()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; a.__next__()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; a.__next__()</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; a.__next__()</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; a.__next__()</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; a.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>生成器</strong><br>一个函数调用时返回一个迭代器，那这个函数就叫做生成器（generator）；如果函数中<code>包含yield语法</code>，那这个函数就会变成<code>生成器</code>；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def func():</span><br><span class="line">    yield 1</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line">    yield 4</span><br></pre></td></tr></table></figure><p>上述代码中：func是函数称为生成器，当执行此函数func()时会得到一个迭代器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; temp = func()</span><br><span class="line">&gt;&gt;&gt; temp.__next__()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; temp.__next__()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; temp.__next__()</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; temp.__next__()</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; temp.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>实例</strong></li></ol><p><em>利用生成器自定义range</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def nrange(num):</span><br><span class="line">    temp = -1</span><br><span class="line">    while True:</span><br><span class="line">        temp = temp + 1</span><br><span class="line">        if temp &gt;= num:</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            yield temp</span><br></pre></td></tr></table></figure><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p><strong><em> 一、数字和字符串</em></strong><br>对于 数字 和 字符串 而言，赋值、浅拷贝和深拷贝无意义，因为其永远指向同一个内存地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"># ######### 数字、字符串 #########</span><br><span class="line">n1 = 123</span><br><span class="line"># n1 = &quot;i am alex age 10&quot;</span><br><span class="line">print(id(n1))</span><br><span class="line"># ## 赋值 ##</span><br><span class="line">n2 = n1</span><br><span class="line">print(id(n2))</span><br><span class="line"># ## 浅拷贝 ##</span><br><span class="line">n2 = copy.copy(n1)</span><br><span class="line">print(id(n2))</span><br><span class="line">  </span><br><span class="line"># ## 深拷贝 ##</span><br><span class="line">n3 = copy.deepcopy(n1)</span><br><span class="line">print(id(n3))</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="./img/2.png" alt="" title="" class="">                <p></p>            </figure><p><strong><em>二、其他基本数据类型</em></strong><br>对于字典、元祖、列表 而言，进行赋值、浅拷贝和深拷贝时，其内存地址的变化是不同的。<br><strong>1、赋值</strong><br>赋值，只是创建一个变量，该变量指向原来内存地址，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n1 = &#123;&quot;k1&quot;: &quot;wu&quot;, &quot;k2&quot;: 123, &quot;k3&quot;: [&quot;alex&quot;, 456]&#125;</span><br><span class="line">n2 = n1</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="./img/3.png" alt="" title="" class="">                <p></p>            </figure><p><strong>2、浅拷贝</strong><br>浅拷贝，在内存中只额外创建第一层数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">n1 = &#123;&quot;k1&quot;: &quot;wu&quot;, &quot;k2&quot;: 123, &quot;k3&quot;: [&quot;alex&quot;, 456]&#125;</span><br><span class="line">n3 = copy.copy(n1)</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="./img/4.png" alt="" title="" class="">                <p></p>            </figure><p><strong>3、深拷贝</strong><br>深拷贝，在内存中将所有的数据重新创建一份（排除最后一层，即：python内部对字符串和数字的优化）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import copy </span><br><span class="line">n1 = &#123;&quot;k1&quot;: &quot;wu&quot;, &quot;k2&quot;: 123, &quot;k3&quot;: [&quot;alex&quot;, 456]&#125;  </span><br><span class="line">n4 = copy.deepcopy(n1)</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="./img/5.png" alt="" title="" class="">                <p></p>            </figure><h1 id="Python2-x与3-x差异与升级py2topy3"><a href="#Python2-x与3-x差异与升级py2topy3" class="headerlink" title="Python2.x与3.x差异与升级py2topy3"></a>Python2.x与3.x差异与升级py2topy3</h1><p><strong><em>Python2和3的区别</em></strong></p><ol><li><code>print</code><br>去除了print表达式，添加了print函数实现相同功能</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2.X: print &quot;The answer is&quot;, 2*2 </span><br><span class="line">3.X: print(&quot;The answer is&quot;, 2*2) </span><br><span class="line">2.X: print x,                # 使用逗号结尾禁止换行 </span><br><span class="line">3.X: print(x, end=&quot; &quot;)       # 使用空格代替换行 </span><br><span class="line">2.X: print                   # 输出新行 </span><br><span class="line">3.X: print()                 # 输出新行 </span><br><span class="line">2.X: print &gt;&gt;sys.stderr, &quot;fatal error&quot; </span><br><span class="line">3.X: print(&quot;fatal error&quot;, file=sys.stderr) </span><br><span class="line">2.X: print (x, y)            # 输出repr((x, y)) </span><br><span class="line">3.X: print((x, y))           # 不同于print(x, y)!</span><br></pre></td></tr></table></figure><ol start="2"><li><code>input</code><br>获取键盘输入的函数raw_input在3.x里被去除，取而代之的是将原来的input改为raw_input的功能（将输入作为字符串保存）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#Python2.x</span><br><span class="line">&gt;&gt;&gt;my_input = input(&apos;enter a number: &apos;)</span><br><span class="line">enter a number: 123</span><br><span class="line">&gt;&gt;&gt;type(my_input)</span><br><span class="line">&lt;type &apos;int&apos;&gt;</span><br><span class="line">&gt;&gt;&gt;my_input = raw_input(&apos;enter a number: &apos;)</span><br><span class="line">enter a number: 123</span><br><span class="line">&gt;&gt;&gt;type(my_input)</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">#Python 3.x</span><br><span class="line">&gt;&gt;&gt;my_input = input(&apos;enter a number: &apos;)</span><br><span class="line">enter a number: 123</span><br><span class="line">&gt;&gt;&gt;type(my_input)</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>编码</code><br>Py3.X源码文件默认使用utf-8编码, 不需要再在文件头上声明</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure><p>Py2有两种字符串类型，non-unicode和unicode。Py3统一都是unicode类型。 Py2用unicode()将数据转换成unicode类型的字符串，str()将数据转换为non-unicode类型的字符串。 Py3统一用str()转换为unicode类型的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#python 2.x</span><br><span class="line">&gt;&gt;&gt;str = &quot;我爱北京天安门&quot;</span><br><span class="line">&gt;&gt;&gt;str</span><br><span class="line">&apos;\xe6\x88\x91\xe7\x88\xb1\xe5\x8c\x97\xe4\xba\xac\xe5\xa4\xa9\xe5\xae\x89\xe9\x97\xa8&apos;</span><br><span class="line">&gt;&gt;&gt;str = u&quot;我爱北京天安门&quot;</span><br><span class="line">&gt;&gt;&gt;str</span><br><span class="line">u&apos;\u6211\u7231\u5317\u4eac\u5929\u5b89\u95e8&apos;</span><br><span class="line">#python 3.x</span><br><span class="line">&gt;&gt;&gt;str = &quot;我爱北京天安门&quot;</span><br><span class="line">&gt;&gt;&gt;str</span><br><span class="line">&apos;我爱北京天安门&apos;</span><br><span class="line">&gt;&gt;&gt;天安门=&apos;tiananmen&apos;</span><br><span class="line">&gt;&gt;&gt;天安门</span><br><span class="line">tiananmen</span><br></pre></td></tr></table></figure><ol start="4"><li><code>类</code><br>Python 2.x中默认都是经典类，只有显式继承了object才是新式类<br>Python 3.x中默认都是新式类，不必显式的继承object<br>新式类跟经典类的差别主要是以下几点:<ol><li>新式类对象可以直接通过class属性获取自身类型:type</li><li>继承搜索的顺序发生了改变,经典类多继承属性搜索顺序: 先深入继承树左侧，再返回，开始找右侧;新式类多继承属性搜索顺序: 先水平搜索，然后再向上移动</li><li>新式类增加了slots内置属性, 可以把实例属性的种类锁定到slots规定的范围之中。</li><li>新式类增加了getattribute方法<br>5.map,reduce,filter<br>这三个函数号称是函数式编程的代表。在Python3.x和Python2.x中也有了很大的差异。<br>首先我们先简单的在Python2.x的交互下输入map和filter,看到它们两者的类型是built-in function:</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; map</span><br><span class="line">&lt;built-in function map&gt;</span><br><span class="line">&gt;&gt;&gt; filter</span><br><span class="line">&lt;built-in function filter&gt;</span><br></pre></td></tr></table></figure><p>它们输出的结果类型都是列表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; map(lambda x:x * 2,[1,2,3]) </span><br><span class="line">[2, 4, 6]</span><br><span class="line">&gt;&gt;&gt; filter(lambda x:x % 2 == 0, range(10))</span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure><p>但是在Python 3.x中它们却不是这个样子了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; map</span><br><span class="line">&lt;class &apos;map&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; map(print,[1,2,3])</span><br><span class="line">&lt;map object at 0xa6fd70c&gt;</span><br><span class="line">&gt;&gt;&gt; filter</span><br><span class="line">&lt;class &apos;filter&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; filter(lambda x:x % 2 == 0, range(10))</span><br><span class="line">&lt;filter object at 0xa6eeeac&gt;</span><br></pre></td></tr></table></figure><p>首先它们从函数变成了类，其次，它们的返回结果也从当初的列表成了一个可迭代的对象, 我们尝试用next函数来进行手工迭代:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = filter(lambda x:x % 2 == 0, range(10))</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>对于比较高端的reduce函数，它在Python 3.x中已经不属于built-in了，被挪到functools模块当中。</p><ol start="6"><li><code>其他</code><br>xrange() 改名为range()<br>迭代器的next()方法改名为<strong>next</strong>()，并增加内置函数next()，用以调用迭代器的<strong>next</strong>()方法<br>不等于Python 3.x中去掉了&lt;&gt;, 只有!=一种写法<br>3.x的整数除也会成为浮点数，比如1/2<br>3.x不允许不同类型的比较<br>3.x将int和long类型统一为int类型，去除long<br>3.x中修改了一些系统库</li></ol><p>2to3.py<br>安装python2.7后，在tools/scripts/文件夹下有个2to3.py，如果你用的python3，想要把课程代码转换成python3的，可以试试使用这个程序来帮助你。使用方法如下：</p><ol><li>将2to3.py复制到需要转换的程序目录，比如本节课程代码bubble_sort.py的目录下</li><li>终端切换到程序目录，执行python 2to3.py -w bubble_sort.py即可，如果-w后跟的是文件夹，它会把文件夹的py文件全部操作一遍。<br>执行后，bubble_sort.py会被修改，原始的文件会产生一个备份。改了哪些地方会在终端上打印出来。<br>还有其他命令参数可以通过python 2to3.py -h来了解。<br>当然也有可能2to3.py搞不定的，它会报错，那就要自己根据错误信息定位了。它还不能完全代替手工转换。。。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初遇Python</title>
      <link href="/2017/03/10/%E5%88%9D%E9%81%87Python/"/>
      <url>/2017/03/10/%E5%88%9D%E9%81%87Python/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h1><h2 id="python的前世今生"><a href="#python的前世今生" class="headerlink" title="python的前世今生"></a>python的前世今生</h2><p>python的创始人为吉多·范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。</p><p>最新的TIOBE排行榜，Python赶超PHP占据第五！！！</p><figure class="image-box">                <img src="../img/0.png" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="../img/1.png" alt="" title="" class="">                <p></p>            </figure> <p>由上图可见，Python整体呈上升趋势，反映出Python应用越来越广泛并且也逐渐得到业内的认可！！！<br>Python可以应用于众多领域，如：数据分析、组件集成、网络服务、图像处理、数值计算和科学计算等众多领域。目前业内几乎所有大中型互联网企业都在使用Python，如：Youtube、Dropbox、BT、Quora（中国知乎）、豆瓣、知乎、Google、Yahoo!、Facebook、NASA、百度、腾讯、汽车之家、美团等。互联网公司广泛使用Python来做的事一般有：<strong>自动化运维</strong>、<strong>自动化测试</strong>、<strong>大数据分析</strong>、<strong>爬虫</strong>、<strong>Web开发</strong>、<strong>人工智能</strong> 等。</p><h2 id="python特点"><a href="#python特点" class="headerlink" title="python特点"></a>python特点</h2><p>• 1.易于学习：Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。<br>• 2.易于阅读：Python代码定义的更清晰。<br>• 3.易于维护：Python的成功在于它的源代码是相当容易维护的。<br>• 4.一个广泛的标准库：Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。<br>• 5.互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。<br>• 6.可移植：基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。<br>• 7.可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。<br>• 8.数据库：Python提供所有主要的商业数据库的接口。<br>• 9.GUI编程：Python支持GUI可以创建和移植到许多系统调用。<br>• 10.可嵌入: 你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。</p><h2 id="Python的种类"><a href="#Python的种类" class="headerlink" title="Python的种类"></a>Python的种类</h2><ol><li><strong>Cpython</strong><br> Python的官方版本，使用C语言实现，使用最为广泛，<br> CPython实现会将源文件（py文件）转换成字节码文件（pyc文件），然后运行在Python虚拟机上。</li><li><strong>Jyhton</strong><br> Python的Java实现，Jython会将Python代码动态编译成Java字节码，然后在JVM上运行。</li><li><strong>IronPython</strong><br> Python的C#实现，IronPython将Python代码编译成C#字节码，然后在CLR上运行。（与Jython类似）</li><li><strong>PyPy（特殊）</strong><br> Python实现的Python，将Python的字节码字节码再编译成机器码。<h2 id="Python编译为pyc文件"><a href="#Python编译为pyc文件" class="headerlink" title="Python编译为pyc文件"></a>Python编译为pyc文件</h2>pyc是一种二进制文件，是由py文件经过编译后，生成的文件，是一种<em>byte code</em>，py文件变成pyc文件后，加载的速度有所提高，而且pyc是一种跨平台的字节码，是由<strong>Python</strong>的虚拟机来执行的，这个是类似于<strong>Java</strong>或者<strong>.NET</strong>的虚拟机的概念。pyc的内容，是跟python的版本相关的，不同版本编译后的pyc文件是不同的，2.5编译的pyc文件，2.4版本的python是无法执行的。</li><li><p>编译单个py文件<br>(1)<br>直接在命令行下执行 <strong><em>python -m py_compile file.py</em></strong><br>(2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   root@ubuntu:/var/# python</span><br><span class="line">  &gt;&gt;&gt; import py_compile</span><br><span class="line">  &gt;&gt;&gt; py_compile.compile(r&apos;/home/test/test.py&apos;)</span><br><span class="line">  &gt;&gt;&gt; py_compile.compile(&apos;webmail_sina.py&apos;)</span><br></pre></td></tr></table></figure></li><li><p>批量生成pyc文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/var/# python</span><br><span class="line">&gt;&gt;&gt; import compileall</span><br><span class="line">&gt;&gt;&gt;compileall.compile_dir(r&apos;/home/codemo/Desktop/python&apos;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="Python的环境"><a href="#Python的环境" class="headerlink" title="Python的环境"></a>Python的环境</h1><h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h2><ul><li><strong>windows</strong></li></ul><ol><li>下载安装包<br> <a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a></li><li>安装<br> 默认安装路径：C:\python27</li><li>配置环境变量<br> 【右键计算机】–》【属性】–》【高级系统设置】–》【高级】–》【环境变量】–》【在第二个内容框中找到 变量名为Path 的一行，双击】 –&gt; 【Python安装目录追加到变值值中，用 ； 分割】<br> 如：原来的值;C:\python27，切记前面有分号</li></ol><ul><li><strong>linux</strong><br>无需安装，原装自带Python环境<br>ps：如果自带2.7，请更新至3.6<h2 id="查看python版本"><a href="#查看python版本" class="headerlink" title="查看python版本"></a>查看python版本</h2>安装Python成功后我们可以进入cmd命令终端使用以下命令来查看我们使用的Python版本：<blockquote><p>python -V<br>以上命令执行结果如下：<br>Python 3.3.2<br>你也可以进入Python的交互式编程模式，查看版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Python 3.3.2 (v3.3.2:d047928ae3f6, May 16 2013, 00:03:43) [MSC v.1600 32 bit (Intel)] on win32</span><br><span class="line">Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license()&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h1 id="Python入门"><a href="#Python入门" class="headerlink" title="Python入门"></a>Python入门</h1><h2 id="一、第一句Python代码"><a href="#一、第一句Python代码" class="headerlink" title="一、第一句Python代码"></a>一、第一句Python代码</h2><p>在 /home/dev/ 目录下创建 hello.py 文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;hello,world&quot;</span><br></pre></td></tr></table></figure></p><p>执行 hello.py 文件，即： python /home/dev/hello.py<br>python内部执行过程如下：<br><figure class="image-box">                <img src="../img/2.png" alt="" title="" class="">                <p></p>            </figure></p><h2 id="二、Python解释器"><a href="#二、Python解释器" class="headerlink" title="二、Python解释器"></a>二、Python解释器</h2><p>上一步中执行 python /home/dev/hello.py 时，明确的指出 hello.py 脚本由 python 解释器来执行。</p><p>如果想要类似于执行shell脚本一样执行python脚本，例： ./hello.py ，那么就需要在 hello.py 文件的头部指定解释器，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">  </span><br><span class="line">print &quot;hello,world</span><br></pre></td></tr></table></figure></p><p>如此一来，执行： ./hello.py 即可。</p><h2 id="三、内容编码"><a href="#三、内容编码" class="headerlink" title="三、内容编码"></a>三、内容编码</h2><p>python解释器在加载 .py 文件中的代码时，会对内容进行编码（默认ascill）</p><p>ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，其最多只能用 8 位来表示（一个字节），即：2**8 = 256，所以，ASCII码最多只能表示 256 个符号。<br>python解释器在加载 .py 文件中的代码时，会对内容进行编码（默认ascill），如果是如下代码的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">  </span><br><span class="line">print &quot;你好，世界&quot;</span><br></pre></td></tr></table></figure></p><p>报错：py2中ascii码无法表示中文或在中文前面加上一个u，py3中则不需要<br>改正：应该显示的告诉python解释器，用什么编码来执行源代码，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">  </span><br><span class="line">print &quot;你好，世界&quot;</span><br></pre></td></tr></table></figure></p><h2 id="四、注释"><a href="#四、注释" class="headerlink" title="四、注释"></a>四、注释</h2><p>单行注视：# 被注释内容<br>多行注释：””” 被注释内容 “””</p><h2 id="五、执行脚本传入参数"><a href="#五、执行脚本传入参数" class="headerlink" title="五、执行脚本传入参数"></a>五、执行脚本传入参数</h2><p>Python有大量的模块，从而使得开发Python程序非常简洁。类库有包括三中：<br>. Python内部提供的模块<br>. 业内开源的模块<br>. 程序员自己开发的模块<br>Python内部提供一个 sys 的模块，其中的 sys.argv 用来捕获执行执行python脚本时传入的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import sys </span><br><span class="line">print sys.argv</span><br></pre></td></tr></table></figure></p><h2 id="六、变量"><a href="#六、变量" class="headerlink" title="六、变量"></a>六、变量</h2><ol><li>声明变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">  </span><br><span class="line">name = &quot;Kevin&quot;</span><br></pre></td></tr></table></figure></li></ol><p>上述代码声明了一个变量，变量名为： name，变量name的值为：”Kevin”<br><strong>变量的作用</strong>：昵称，其代指内存里某个地址中保存的内容<br><figure class="image-box">                <img src="../img/4.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>变量定义的规则：</p><ul><li>变量名只能是 字母、数字或下划线的任意组合</li><li>变量名的第一个字符不能是数字</li><li>以下关键字不能声明为变量名<br>  [‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</li></ul><ol start="2"><li>变量的赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">name1 = &quot;Kevin&quot;</span><br><span class="line">name2 = &quot;Peter&quot;</span><br></pre></td></tr></table></figure></li></ol><figure class="image-box">                <img src="../img/5.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">name1 = &quot;Kevin&quot;</span><br><span class="line">name2 = name1</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="../img/6.jpg" alt="" title="" class="">                <p></p>            </figure><h2 id="七、输入和输出"><a href="#七、输入和输出" class="headerlink" title="七、输入和输出"></a>七、输入和输出</h2><p><1><strong>输出</strong><br>. 生活中的“输出”<br><figure class="image-box">                <img src="../img/7.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="../img/8.jpg" alt="" title="" class="">                <p></p>            </figure><br>. 软件中的“输出”<br><figure class="image-box">                <img src="../img/9.jpg" alt="" title="" class="">                <p></p>            </figure></1></p><p>. python中变量的输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#打印提示</span><br><span class="line">print(&apos;hello world&apos;)</span><br><span class="line">print(&apos;给我的卡---印度语，你好的意思&apos;)</span><br><span class="line">#输出变量</span><br><span class="line">url = &apos;www.tsinghua.edu.cn&apos;</span><br><span class="line">print(&apos;我们的网址是%s&apos;%url)</span><br></pre></td></tr></table></figure><p><2><strong>输入</strong></2></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- coding: utf-8 -*-</span><br><span class="line">#将用户输入的内容赋值给 name 变量</span><br><span class="line">name = raw_input(&quot;请输入用户名：&quot;)</span><br><span class="line">#打印输入的内容</span><br><span class="line">print name</span><br></pre></td></tr></table></figure><h2 id="八、流程控制"><a href="#八、流程控制" class="headerlink" title="八、流程控制"></a>八、流程控制</h2><p>Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。<br>可以通过下图来简单了解条件语句的执行过程:<br><figure class="image-box">                <img src="../img/10.jpg" alt="" title="" class="">                <p></p>            </figure></p><ul><li><strong>if 语句</strong><br>Python中if语句的一般形式如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line">elif condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line">else:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure></li></ul><p>• 如果 “condition_1” 为 True 将执行 “statement_block_1” 块语句<br>• 如果 “condition_1” 为False，将判断 “condition_2”<br>• 如果”condition_2” 为 True 将执行 “statement_block_2” 块语句<br>• 如果 “condition_2” 为False，将执行”statement_block_3”块语句<br>Python 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else。<br>注意：<br>• 1、每个条件后面要使用冒号（:），表示接下来是满足条件后要执行的语句块。<br>• 2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。<br>• 3、在Python中没有switch – case语句。</p><ul><li><strong>实例</strong><br>以下是一个简单的 if 实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">var1 = 100</span><br><span class="line">if var1:</span><br><span class="line">   print (&quot;1 - if 表达式条件为 true&quot;)</span><br><span class="line">   print (var1)</span><br><span class="line">var2 = 0</span><br><span class="line">if var2:</span><br><span class="line">   print (&quot;2 - if 表达式条件为 true&quot;)</span><br><span class="line">   print (var2)</span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure></li></ul><p>执行以上代码，输出结果为：</p><blockquote><p>1 - if 表达式条件为 true<br>100<br>Good bye!</p></blockquote><p>从结果可以看到由于变量 var2 为 0，所以对应的 if 内的语句没有执行。<br>以下实例演示了狗的年龄计算判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">age = int(input(&quot;请输入你家狗狗的年龄: &quot;))</span><br><span class="line">print(&quot;&quot;)</span><br><span class="line">if age &lt; 0:</span><br><span class="line">print(&quot;你是在逗我吧!&quot;)</span><br><span class="line">elif age == 1:</span><br><span class="line">print(&quot;相当于 14 岁的人。&quot;)</span><br><span class="line">elif age == 2:</span><br><span class="line">print(&quot;相当于 22 岁的人。&quot;)</span><br><span class="line">elif age &gt; 2:</span><br><span class="line">human = 22 + (age -2)*5</span><br><span class="line">print(&quot;对应人类年龄: &quot;, human)</span><br><span class="line">### 退出提示</span><br><span class="line">input(&quot;点击 enter 键退出&quot;)</span><br></pre></td></tr></table></figure></p><p>将以上脚本保存在dog.py文件中，并执行该脚本：</p><blockquote><p>$ python3 dog.py </p></blockquote><p><em>输出结果：</em></p><blockquote><p>请输入你家狗狗的年龄: 1<br>相当于 14 岁的人。<br>点击 enter 键退出</p></blockquote><p>以下为if中常用的操作运算符:</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于或等于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于或等于</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">等于，比较对象是否相等</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不等于</td></tr></tbody></table><p><strong>if 嵌套</strong><br>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中。</p><pre><code>if 表达式1:    语句    if 表达式2:        语句    elif 表达式3:        语句    else        语句elif 表达式4:    语句else:    语句</code></pre><h2 id="九、循环语句"><a href="#九、循环语句" class="headerlink" title="九、循环语句"></a>九、循环语句</h2><p>Python中的循环语句有 for 和 while。<br>Python循环语句的控制结构图如下所示：<br><figure class="image-box">                <img src="../img/11.png" alt="" title="" class="">                <p></p>            </figure></p><ol><li><p><strong>基本循环</strong></p><p> while 条件:</p><pre><code>循环体如果条件为真，那么循环体则执行如果条件为假，那么循环体不执行</code></pre></li><li><p><strong>break</strong></p><p> break用于退出所有循环</p><pre><code>while True:    print &quot;123&quot;    break    print &quot;456&quot;</code></pre></li><li><p><strong>continue</strong></p><p> continue用于退出当前循环，继续下一次循环</p><pre><code>while True:    print &quot;123&quot;    continue    print &quot;456&quot;</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
