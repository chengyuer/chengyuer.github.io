<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    
    <title>与Python进阶 | 人生苦短，我用Python | 不想做架构的码农不是好司机</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="Python">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.3.2">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/pro.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">煜立王冠</h5>
          <a href="mailto:18370808967@163.com" title="18370808967@163.com" class="mail">
            
              <span>1</span>
            
              <span>8</span>
            
              <span>3</span>
            
              <span>7</span>
            
              <span>0</span>
            
              <span>8</span>
            
              <span>0</span>
            
              <span>8</span>
            
              <span>9</span>
            
              <span>6</span>
            
              <span>7</span>
            
              <span>@</span>
            
              <span>1</span>
            
              <span>6</span>
            
              <span>3</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/chengyuer" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
            <li class="">
              <a href="/custom">
                <i class="icon icon-lg icon-plus-square"></i>
                CUSTOM
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>与Python进阶</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">与Python进阶</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-03-15T11:03:26.000Z" itemprop="datePublished" class="page-time">
  2017-03-15
</time>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left">
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-与Python进阶" class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">与Python进阶</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-03-15 19:03:26" datetime="2017-03-15T11:03:26.000Z" itemprop="datePublished">2017-03-15</time>

            


            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <p>[TOC]</p>
<h1 id="Pyhton中的函数"><a href="#Pyhton中的函数" class="headerlink" title="Pyhton中的函数"></a>Pyhton中的函数</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>在学习函数之前，一直遵循：面向过程编程，即：根据业务逻辑从上到下实现功能，其往往用一长段代码来实现指定功能，开发过程中最常见的操作就是粘贴复制，也就是将之前实现的代码块复制到现需功能处，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while True：</span><br><span class="line">    if 小明饿了:</span><br><span class="line">       蒸饭</span><br><span class="line">       洗菜</span><br><span class="line">       炒菜</span><br><span class="line">       吃饭</span><br><span class="line">    if 小红饿了:</span><br><span class="line">        蒸饭</span><br><span class="line">        洗菜</span><br><span class="line">        炒菜</span><br><span class="line">        吃饭</span><br><span class="line">    if 小华饿了:</span><br><span class="line">        蒸饭</span><br><span class="line">        洗菜</span><br><span class="line">        炒菜</span><br><span class="line">        吃饭</span><br></pre></td></tr></table></figure>
<p>定眼一看上述代码，if条件语句下的内容可以被提取出来公用，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def 吃(内容)：</span><br><span class="line">        蒸饭</span><br><span class="line">        洗菜</span><br><span class="line">        炒菜</span><br><span class="line">        吃饭</span><br><span class="line">    </span><br><span class="line">while True：</span><br><span class="line">    </span><br><span class="line">    if 小明饿了:</span><br><span class="line">        吃(&apos;吃饭&apos;)</span><br><span class="line">    </span><br><span class="line">    if 小红饿了:</span><br><span class="line">        吃(&apos;吃饭&apos;)</span><br><span class="line">    </span><br><span class="line">    if 小华饿了:</span><br><span class="line">        吃（&apos;吃饭&apos;）</span><br></pre></td></tr></table></figure>
<p>对于上述的两种实现方式，第二次必然比第一次的重用性和可读性要好，其实这就是函数式编程和面向过程编程的区别：</p>
<p>函数式：将某功能代码封装到函数中，日后便无需重复编写，仅调用函数即可<br>面向对象：对函数进行分类和封装，让开发“更快更好更强…”<br>函数式编程最重要的是增强代码的重用性和可读性</p>
<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>定义一个函数<br>你可以定义一个由自己想要功能的函数，以下是简单的规则：<br>• 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。<br>• 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。<br>• 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。<br>• 函数内容以冒号起始，并且缩进。<br>• return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</p>
<p><code>语法</code><br>Python 定义函数使用 def 关键字，一般格式如下：<br>def 函数名（参数列表）:<br>    函数体<br>默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。</p>
<p><code>实例</code><br>让我们使用函数来输出”Hello World！”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def hello() :</span><br><span class="line">   print(&quot;Hello World!&quot;)</span><br><span class="line">&gt;&gt;&gt; hello()</span><br><span class="line">Hello World!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>更复杂点的应用，函数中带上参数变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># 计算面积函数</span><br><span class="line">def area(width, height):</span><br><span class="line">    return width * height</span><br><span class="line"> </span><br><span class="line">def print_welcome(name):</span><br><span class="line">    print(&quot;Welcome&quot;, name)</span><br><span class="line">print_welcome(&quot;Runoob&quot;)</span><br><span class="line">w = 4</span><br><span class="line">h = 5</span><br><span class="line">print(&quot;width =&quot;, w, &quot; height =&quot;, h, &quot; area =&quot;, area(w, h))</span><br><span class="line">以上实例输出结果：</span><br><span class="line">Welcome Runoob</span><br><span class="line">width = 4  height = 5  area = 20</span><br></pre></td></tr></table></figure>
<h2 id="三、函数调用"><a href="#三、函数调用" class="headerlink" title="三、函数调用"></a>三、函数调用</h2><p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。<br>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。<br>如下实例调用了 printme() 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># 定义函数</span><br><span class="line">def printme( str ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (str);</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line"># 调用函数</span><br><span class="line">printme(&quot;我要调用用户自定义函数!&quot;);</span><br><span class="line">printme(&quot;再次调用同一函数&quot;);</span><br><span class="line">以上实例输出结果：</span><br><span class="line">我要调用用户自定义函数!</span><br><span class="line">再次调用同一函数</span><br></pre></td></tr></table></figure>
<h2 id="四、参数传递"><a href="#四、参数传递" class="headerlink" title="四、参数传递"></a>四、参数传递</h2><p>在 python 中，类型属于对象，变量是没有类型的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=[1,2,3]</span><br><span class="line">a=&quot;百度&quot;</span><br></pre></td></tr></table></figure>
<p>以上代码中，[1,2,3] 是 List 类型，”百度” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的<code>引用</code>（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。<br><code>可更改(mutable)与不可更改(immutable)对象</code><br>在 python 中，<strong>strings, tuples, 和 numbers 是不可更改的对象</strong>，而 <strong>list,dict 等则是可以修改的对象</strong>。<br>• 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。<br>• 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</p>
<p><strong><em>python 函数的参数传递</em></strong>：<br>• 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。<br>• 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响<br>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>
<p>python 传不可变对象实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">def ChangeInt( a ):</span><br><span class="line">    a = 10</span><br><span class="line">b = 2</span><br><span class="line">ChangeInt(b)</span><br><span class="line">print( b ) # 结果是 2</span><br></pre></td></tr></table></figure>
<p>实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。</p>
<p>传可变对象实例<br>可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">def changeme( mylist ):</span><br><span class="line">   &quot;修改传入的列表&quot;</span><br><span class="line">   mylist.append([1,2,3,4]);</span><br><span class="line">   print (&quot;函数内取值: &quot;, mylist)</span><br><span class="line">   return</span><br><span class="line"> </span><br><span class="line"># 调用changeme函数</span><br><span class="line">mylist = [10,20,30];</span><br><span class="line">changeme( mylist );</span><br><span class="line">print (&quot;函数外取值: &quot;, mylist)</span><br></pre></td></tr></table></figure>
<p>传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：</p>
<blockquote>
<p>函数内取值:  [10, 20, 30, [1, 2, 3, 4]]<br>函数外取值:  [10, 20, 30, [1, 2, 3, 4]]</p>
</blockquote>
<h2 id="五、参数"><a href="#五、参数" class="headerlink" title="五、参数"></a>五、参数</h2><p>以下是调用函数时可使用的正式参数类型：<br>• <strong>必需参数</strong><br>• <strong>关键字参数</strong><br>• <strong>默认参数</strong><br>• <strong>不定长参数</strong></p>
<p><strong>必需参数</strong><br>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。<br>调用printme()函数，你必须传入一个参数，不然会出现语法错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printme( str ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (str);</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line">#调用printme函数</span><br><span class="line">printme();</span><br><span class="line">以上实例输出结果：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 10, in &lt;module&gt;</span><br><span class="line">    printme();</span><br><span class="line">TypeError: printme() missing 1 required positional argument: &apos;str&apos;</span><br></pre></td></tr></table></figure>
<p><strong>关键字参数</strong><br>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。<br>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。<br>以下实例在函数 printme() 调用时使用参数名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printme( str ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (str);</span><br><span class="line">   return;</span><br><span class="line"></span><br><span class="line">#调用printme函数</span><br><span class="line">printme( str = &quot;百度论坛&quot;);</span><br><span class="line">以上实例输出结果：</span><br><span class="line">百度论坛</span><br></pre></td></tr></table></figure>
<p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printinfo( name, age ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (&quot;名字: &quot;, name);</span><br><span class="line">   print (&quot;年龄: &quot;, age);</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line">#调用printinfo函数</span><br><span class="line">printinfo( age=50, name=&quot;baidu&quot; );</span><br><span class="line">以上实例输出结果：</span><br><span class="line">名字:  baidu</span><br><span class="line">年龄:  50</span><br></pre></td></tr></table></figure>
<p><strong>默认参数</strong><br>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printinfo( name, age = 35 ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (&quot;名字: &quot;, name);</span><br><span class="line">   print (&quot;年龄: &quot;, age);</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line">#调用printinfo函数</span><br><span class="line">printinfo( age=50, name=&quot;BAIDU&quot; );</span><br><span class="line">print (&quot;------------------------&quot;)</span><br><span class="line">printinfo( name=&quot;BAIDU&quot; );</span><br><span class="line">以上实例输出结果：</span><br><span class="line">名字:  BAIDU</span><br><span class="line">年龄:  50</span><br><span class="line">------------------------</span><br><span class="line">名字:  BAIDU</span><br><span class="line">年龄:  35</span><br></pre></td></tr></table></figure>
<p><strong>不定长参数</strong><br>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def functionname([formal_args,] *var_args_tuple ):</span><br><span class="line">   &quot;函数_文档字符串&quot;</span><br><span class="line">   function_suite</span><br><span class="line">   return [expression]</span><br></pre></td></tr></table></figure>
<p>加了星号（*）的变量名会存放所有未命名的变量参数。如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">def printinfo( arg1, *vartuple ):</span><br><span class="line">   &quot;打印任何传入的参数&quot;</span><br><span class="line">   print (&quot;输出: &quot;)</span><br><span class="line">   print (arg1)</span><br><span class="line">   for var in vartuple:</span><br><span class="line">      print (var)</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line"># 调用printinfo 函数</span><br><span class="line">printinfo( 10 );</span><br><span class="line">printinfo( 70, 60, 50 );</span><br><span class="line">以上实例输出结果：</span><br><span class="line">输出:</span><br><span class="line">10</span><br><span class="line">输出:</span><br><span class="line">70</span><br><span class="line">60</span><br><span class="line">50</span><br></pre></td></tr></table></figure>
<p><strong>匿名函数</strong><br>python 使用 lambda 来创建匿名函数。<br>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。<br>• lambda 只是一个表达式，函数体比 def 简单很多。<br>• lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。<br>• lambda 函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。<br>• 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。<br><em>语法</em><br>lambda 函数的语法只包含一个语句，如下：<br>lambda [arg1 [,arg2,…..argn]]:expression<br>如下实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">sum = lambda arg1, arg2: arg1 + arg2;</span><br><span class="line"> </span><br><span class="line"># 调用sum函数</span><br><span class="line">print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))</span><br><span class="line">print (&quot;相加后的值为 : &quot;, sum( 20, 20 ))</span><br><span class="line">以上实例输出结果：</span><br><span class="line">相加后的值为 :  30</span><br><span class="line">相加后的值为 :  40</span><br></pre></td></tr></table></figure>
<p><em>return语句</em><br>return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># 可写函数说明</span><br><span class="line">def sum( arg1, arg2 ):</span><br><span class="line">   # 返回2个参数的和.&quot;</span><br><span class="line">   total = arg1 + arg2</span><br><span class="line">   print (&quot;函数内 : &quot;, total)</span><br><span class="line">   return total;</span><br><span class="line"># 调用sum函数</span><br><span class="line">total = sum( 10, 20 );</span><br><span class="line">print (&quot;函数外 : &quot;, total)</span><br><span class="line">以上实例输出结果：</span><br><span class="line">函数内 :  30</span><br><span class="line">函数外 :  30</span><br></pre></td></tr></table></figure>
<p><strong>变量作用域</strong><br>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。<br>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4中，分别是：<br>• L （Local） 局部作用域<br>• E （Enclosing） 闭包函数外的函数中<br>• G （Global） 全局作用域<br>• B （Built-in） 内建作用域<br>以 <code>L –&gt; E –&gt; G –&gt;B</code> 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = int(2.9)  # 内建作用域</span><br><span class="line">g_count = 0  # 全局作用域</span><br><span class="line">def outer():</span><br><span class="line">    o_count = 1  # 闭包函数外的函数中</span><br><span class="line">    def inner():</span><br><span class="line">        i_count = 2  # 局部作用域</span><br></pre></td></tr></table></figure>
<p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这这些语句内定义的变量，外部也可以访问，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; if True:</span><br><span class="line">...  msg = &apos;I am from GOOGLE&apos;</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; msg</span><br><span class="line">&apos;I am from GOOGLE&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。<br>如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def test():</span><br><span class="line">...     msg_inner = &apos;I am from Runoob&apos;</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; msg_inner</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &apos;msg_inner&apos; is not defined</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p>
<p><em>全局变量和局部变量</em><br>定义在<code>函数内部的变量</code>拥有一个<code>局部作用域</code>，定义在<code>函数外</code>的拥有<code>全局作用域</code>。<br>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">total = 0; # 这是一个全局变量</span><br><span class="line"># 可写函数说明</span><br><span class="line">def sum( arg1, arg2 ):</span><br><span class="line">    #返回2个参数的和.&quot;</span><br><span class="line">    total = arg1 + arg2; # total在这里是局部变量.</span><br><span class="line">    print (&quot;函数内是局部变量 : &quot;, total)</span><br><span class="line">    return total;</span><br><span class="line">#调用sum函数</span><br><span class="line">sum( 10, 20 );</span><br><span class="line">print (&quot;函数外是全局变量 : &quot;, total)</span><br><span class="line">以上实例输出结果：</span><br><span class="line">函数内是局部变量 :  30</span><br><span class="line">函数外是全局变量 :  0</span><br></pre></td></tr></table></figure>
<p><em>global 和 nonlocal关键字</em><br>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。<br>以下实例修改全局变量 num：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">num = 1</span><br><span class="line">def fun1():</span><br><span class="line">    global num  # 需要使用 global 关键字声明</span><br><span class="line">    print(num) </span><br><span class="line">    num = 123</span><br><span class="line">    print(num)</span><br><span class="line">fun1()</span><br><span class="line">以上实例输出结果：</span><br><span class="line">1</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">def outer():</span><br><span class="line">    num = 10</span><br><span class="line">    def inner():</span><br><span class="line">        nonlocal num   # nonlocal关键字声明</span><br><span class="line">        num = 100</span><br><span class="line">        print(num)</span><br><span class="line">    inner()</span><br><span class="line">    print(num)</span><br><span class="line">outer()</span><br><span class="line">以上实例输出结果：</span><br><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<p>另外有一种特殊情况，假设下面这段代码被运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">a = 10</span><br><span class="line">def test():</span><br><span class="line">    a = a + 1</span><br><span class="line">    print(a)</span><br><span class="line">test()</span><br><span class="line">以上程序执行，报错信息如下：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    test()</span><br><span class="line">  File &quot;test.py&quot;, line 5, in test</span><br><span class="line">    a = a + 1</span><br><span class="line">UnboundLocalError: local variable &apos;a&apos; referenced before assignment</span><br></pre></td></tr></table></figure>
<p>错误信息为局部作用域引用错误，因为函数的内部使用外部作用域的变量时，这个变量是只读的，是不能修改。</p>
<h1 id="Python中的面向对象"><a href="#Python中的面向对象" class="headerlink" title="Python中的面向对象"></a>Python中的面向对象</h1><h2 id="浅析面向对象编程"><a href="#浅析面向对象编程" class="headerlink" title="浅析面向对象编程"></a>浅析面向对象编程</h2><p>• 面向过程：根据业务逻辑从上到下写垒代码<br>• 函数式：将某功能代码封装到函数中，无需重复编写整个功能代码的实现，仅调用即可<br>• 面向对象：对函数进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程<br>面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程中最常见的操作就是粘贴复制，即：将之前实现的代码块复制到现需功能处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    while True：</span><br><span class="line">        if cpu利用率 &gt; 90%:</span><br><span class="line">            #发送邮件提醒</span><br><span class="line">            连接邮箱服务器</span><br><span class="line">            发送邮件</span><br><span class="line">            关闭连接</span><br><span class="line">if 硬盘使用空间 &gt; 90%:</span><br><span class="line">            #发送邮件提醒</span><br><span class="line">            连接邮箱服务器</span><br><span class="line">            发送邮件</span><br><span class="line">            关闭连接</span><br><span class="line">if 内存占用 &gt; 80%:</span><br><span class="line">            #发送邮件提醒</span><br><span class="line">            连接邮箱服务器</span><br><span class="line">            发送邮件</span><br><span class="line">            关闭连接</span><br><span class="line">随着时间的推移，开始使用了函数式编程，增强代码的重用性和可读性，就变成了这样：</span><br><span class="line">    def 发送邮件(内容)</span><br><span class="line">        #发送邮件提醒</span><br><span class="line">        连接邮箱服务器</span><br><span class="line">        发送邮件</span><br><span class="line">        关闭连接</span><br><span class="line">while True：</span><br><span class="line">if cpu利用率 &gt; 90%:</span><br><span class="line">            发送邮件(&apos;CPU报警&apos;)</span><br><span class="line">if 硬盘使用空间 &gt; 90%:</span><br><span class="line">            发送邮件(&apos;硬盘报警&apos;)</span><br><span class="line">if 内存占用 &gt; 80%:</span><br><span class="line">            发送邮件(&apos;内存报警&apos;)</span><br></pre></td></tr></table></figure>
<p>今天我们来学习一种新的编程方式：面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）<br>    • 1）解决小明买电脑的故事<br>第一种方式:<br>1)在网上查找资料<br>2)根据自己预算和需求定电脑的型号 MacBook 15 顶配 1W8<br>3)去市场找到苹果店各种店无法甄别真假 随便找了一家<br>4)找到业务员,业务员推荐了另外一款 配置更高价格便宜,也是苹果系统的 1W<br>5)砍价30分钟 付款9999<br>6)成交<br>回去之后发现各种问题<br>第二种方式 :<br>1)找一个靠谱的电脑高手<br>2)给钱交易<br>    • 面向对象和面向过程都是解决问题的一种思路而已<br>    • 买电脑的第一种方式: 强调的是步骤、过程、每一步都是自己亲自去实现的 这种解决问题的思路我们就叫做面向过程<br>    • 买电脑的第二种方式: 强调的是电脑高手, 电脑高手是处理这件事的主角,对我们而言,我们并不必亲自实现整个步骤,只需要调用电脑高手就可以解决问题 这种解决问题的思路就 是面向对象<br>    • 用面向对象的思维解决问题的重点 1)当遇到一个需求的时候不用自己去实现，如果自己一步步实现那就是面向过程 2)应该找一个专门做这个事的人来做 3)面向对象是基于面向过程的<br>    • 2）解决吃啤酒鸭的问题<br>第一种方式（<code>面向过程</code>）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1)养鸭子</span><br><span class="line">2)鸭子长成</span><br><span class="line">3)杀</span><br><span class="line">4)作料</span><br><span class="line">5)烹饪</span><br><span class="line">6)吃</span><br><span class="line">7)卒</span><br></pre></td></tr></table></figure>
<p>第二种方式（<code>面向对象</code>）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1)找个卖啤酒鸭的人</span><br><span class="line">2)给钱 交易</span><br><span class="line">3)吃</span><br><span class="line">4)胖6斤</span><br></pre></td></tr></table></figure>
<p>需要了解的定义性文字:<br>面向对象(object-oriented ;简称: OO) 至今还没有统一的概念 我这里把它定义为: 按人们 认识客观世界的系统思维方式,采用基于对象(实体) 的概念建立模型,模拟客观世界分析、设 计、实现软件的办法。<br>面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><strong>类和对象</strong><br>面向对象编程的2个非常重要的概念：类和对象<br>对象是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——类<br>类就相当于制造飞机时的图纸，用它来进行创建的飞机就相当于对象</p>
<ol>
<li><em>类</em><br>人以类聚 物以群分。<br>具有相似内部状态和运动规律的实体的集合(或统称、抽象)。<br>具有相同属性和行为事物的统称<br>类是抽象的,在使用的时候通常会找到这个类的一个具体的存在,使用这个具体的存在。一个类可以找到多个对象<figure class="image-box">
                <a rel="与Python进阶" href="./img/1.png" title="undefined" data-fancybox="images"><img src="./img/1.png" alt="" title="" class=""></a>
                <p></p>
            </figure></li>
<li><em>对象</em><br>某一个具体事物的存在 ,在现实世界中可以是看得见摸得着的。可以是直接使用的<figure class="image-box">
                <a rel="与Python进阶" href="./img/2.png" title="undefined" data-fancybox="images"><img src="./img/2.png" alt="" title="" class=""></a>
                <p></p>
            </figure></li>
<li><em>类和对象之间的关系</em><figure class="image-box">
                <a rel="与Python进阶" href="./img/3.png" title="undefined" data-fancybox="images"><img src="./img/3.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
小总结：类就是创建对象的模板</li>
<li><em>练习：区分类和对象</em><br>奔驰汽车 类<br>奔驰smart 类<br>张三的那辆奔驰smart 对象<br>狗 类<br>大黄狗 类<br>李四家那只大黄狗 对象<br>水果 类<br>苹果 类<br>红苹果 类 红富士苹果 类<br>我嘴里吃了一半的苹果 对象<br>5.<em>类的构成</em><br>类(Class) 由3个部分构成<br>• <code>类的名称:类名</code><br>• <code>类的属性:一组数据</code><br>• <code>类的方法:允许对进行操作的方法 (行为)</code><br><1> 举例：<br>1）人的类设计,只关心3样东西:<br>• 事物名称(类名):人(Person)<br>• 属性:身高(height)、年龄(age)<br>• 方法(行为/功能):跑(run)、打架(fight)<br>2）狗类的设计<br>• 类名:狗(Dog)<br>• 属性:品种 、毛色、性别、名字、 腿儿的数量<br>方法(行为/功能):叫 、跑、咬人、吃、摇尾巴</1></li>
</ol>
<p>6.<em>类的抽象</em><br>如何把日常生活中的事物抽象成程序中的类?<br>拥有相同(或者类似)属性和行为的对象都可以抽像出一个类<br>方法:一般名词都是类(名词提炼法)</p>
<p><1> 坦克发射3颗炮弹轰掉了2架飞机<br>• 坦克–》可以抽象成 类<br>• 炮弹–》可以抽象成类<br>• 飞机-》可以抽象成类</1></p>
<p><2> 小明在公车上牵着一条叼着热狗的狗<br>• 小明–》 人类<br>• 公车–》 交通工具类<br>• 热狗–》 食物类<br>• 狗–》 狗类</2></p>
<p><3>【想一想】如下图中，有哪些类呢？<br><figure class="image-box">
                <a rel="与Python进阶" href="./img/4.png" title="undefined" data-fancybox="images"><img src="./img/4.png" alt="" title="" class=""></a>
                <p></p>
            </figure><br>说明：<br>• 人<br>• 枪<br>• 子弹<br>• 手榴弹<br>• 刀子<br>• 箱子</3></p>
<h2 id="Python面向对象"><a href="#Python面向对象" class="headerlink" title="Python面向对象"></a>Python面向对象</h2><p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。<br>如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。<br>接下来我们先来简单的了解下面向对象的一些基本特征。</p>
<p><strong>面向对象技术简介</strong><br>• <code>类(Class):</code> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。<br>• <code>类变量：</code>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。<br>• <code>数据成员：</code>类变量或者实例变量用于处理类及其实例对象的相关的数据。<br>• <code>方法重写：</code>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。<br>• <code>实例变量：</code>定义在方法中的变量，只作用于当前实例的类。<br>• <code>继承：</code>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。<br>• <code>实例化：</code>创建一个类的实例，类的具体对象。<br>• <code>方法：</code>类中定义的函数。<br>• <code>对象：</code>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。<br>和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。<br>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。<br>对象可以包含任意数量和类型的数据。<br><em>类定义</em><br>语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ClassName:</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。<br>类对象<br>类对象支持两种操作：<code>属性引用和实例化</code>。<br>属性引用使用和 Python 中所有的属性引用一样的标准语法：<code>obj.name</code>。<br>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">class MyClass:</span><br><span class="line">    &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span><br><span class="line">    i = 12345</span><br><span class="line">    def f(self):</span><br><span class="line">        return &apos;hello world&apos;</span><br><span class="line"># 实例化类</span><br><span class="line">x = MyClass()</span><br><span class="line"># 访问类的属性和方法</span><br><span class="line">print(&quot;MyClass 类的属性 i 为：&quot;, x.i)</span><br><span class="line">print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f())</span><br><span class="line">实例化类：</span><br><span class="line"># 实例化类</span><br><span class="line">x = MyClass()</span><br><span class="line"># 访问类的属性和方法</span><br><span class="line">以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">MyClass 类的属性 i 为： 12345</span><br><span class="line">MyClass 类的方法 f 输出为： hello world</span><br></pre></td></tr></table></figure>
<p>很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为 <code>__init__()</code>的特殊方法（构造方法），像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    self.data = []</span><br><span class="line">类定义了 __init__() 方法的话，类的实例化操作会自动调用 __init__() 方法。所以在下例中，可以这样创建一个新的实例:</span><br><span class="line">x = MyClass()</span><br><span class="line">当然， __init__() 方法可以有参数，参数通过 __init__() 传递到类的实例化操作上。例如:</span><br><span class="line">&gt;&gt;&gt; class Complex:</span><br><span class="line">...     def __init__(self, realpart, imagpart):</span><br><span class="line">...         self.r = realpart</span><br><span class="line">...         self.i = imagpart</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; x = Complex(3.0, -4.5)</span><br><span class="line">&gt;&gt;&gt; x.r, x.i</span><br><span class="line">(3.0, -4.5)</span><br></pre></td></tr></table></figure>
<p>self代表类的实例，而非类<br>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">    def prt(self):</span><br><span class="line">        print(self)</span><br><span class="line">        print(self.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line">以上实例执行结果为：</span><br><span class="line">&lt;__main__.Test instance at 0x100771878&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure>
<p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。<br>self 不是 python 关键字，我们把他换成 baidu 也是可以正常执行的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">    def prt(baidu):</span><br><span class="line">        print(baidu)</span><br><span class="line">        print(baidu.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line">以上实例执行结果为：</span><br><span class="line">&lt;__main__.Test instance at 0x100771878&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure>
<p><em>类的方法</em><br>在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">#类定义</span><br><span class="line">class people:</span><br><span class="line">    #定义基本属性</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    #定义私有属性,私有属性在类外部无法直接进行访问</span><br><span class="line">    __weight = 0</span><br><span class="line">    #定义构造方法</span><br><span class="line">    def __init__(self,n,a,w):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))</span><br><span class="line"># 实例化类</span><br><span class="line">p = people(&apos;baidu&apos;,10,30)</span><br><span class="line">p.speak()</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">baidu 说: 我 10 岁。</span><br></pre></td></tr></table></figure>
<p><em>继承</em><br>Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DerivedClassName(BaseClassName1):</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法。<br>BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:<br>class DerivedClassName(modname.BaseClassName):<br>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">#类定义</span><br><span class="line">class people:</span><br><span class="line">    #定义基本属性</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    #定义私有属性,私有属性在类外部无法直接进行访问</span><br><span class="line">    __weight = 0</span><br><span class="line">    #定义构造方法</span><br><span class="line">    def __init__(self,n,a,w):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))</span><br><span class="line">#单继承示例</span><br><span class="line">class student(people):</span><br><span class="line">    grade = &apos;&apos;</span><br><span class="line">    def __init__(self,n,a,w,g):</span><br><span class="line">        #调用父类的构函</span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    #覆写父类的方法</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))</span><br><span class="line">s = student(&apos;ken&apos;,10,60,3)</span><br><span class="line">s.speak()</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">ken 说: 我 10 岁了，我在读 3 年级</span><br></pre></td></tr></table></figure>
<p><em>多继承</em><br>Python同样有限的支持多继承形式。多继承的类定义形如下例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DerivedClassName(Base1, Base2, Base3):</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">#类定义</span><br><span class="line">class people:</span><br><span class="line">    #定义基本属性</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    age = 0</span><br><span class="line">    #定义私有属性,私有属性在类外部无法直接进行访问</span><br><span class="line">    __weight = 0</span><br><span class="line">    #定义构造方法</span><br><span class="line">    def __init__(self,n,a,w):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))</span><br><span class="line">#单继承示例</span><br><span class="line">class student(people):</span><br><span class="line">    grade = &apos;&apos;</span><br><span class="line">    def __init__(self,n,a,w,g):</span><br><span class="line">        #调用父类的构函</span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    #覆写父类的方法</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))</span><br><span class="line">#另一个类，多重继承之前的准备</span><br><span class="line">class speaker():</span><br><span class="line">    topic = &apos;&apos;</span><br><span class="line">    name = &apos;&apos;</span><br><span class="line">    def __init__(self,n,t):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))</span><br><span class="line">#多重继承</span><br><span class="line">class sample(speaker,student):</span><br><span class="line">    a =&apos;&apos;</span><br><span class="line">    def __init__(self,n,a,w,g,t):</span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line">test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)</span><br><span class="line">test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">我叫 Tim，我是一个演说家，我演讲的主题是 Python</span><br></pre></td></tr></table></figure>
<p><em>方法重写</em><br>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">class Parent:        # 定义父类</span><br><span class="line">   def myMethod(self):</span><br><span class="line">      print (&apos;调用父类方法&apos;)</span><br><span class="line">class Child(Parent): # 定义子类</span><br><span class="line">   def myMethod(self):</span><br><span class="line">      print (&apos;调用子类方法&apos;)</span><br><span class="line">c = Child()          # 子类实例</span><br><span class="line">c.myMethod()         # 子类调用重写方法</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">调用子类方法</span><br></pre></td></tr></table></figure>
<p><em>类属性与方法</em></p>
<ol>
<li><code>类的私有属性</code><blockquote>
<p><strong>private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.</strong>private_attrs。</p>
</blockquote>
</li>
<li><code>类的方法</code><blockquote>
<p>在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数</p>
</blockquote>
</li>
<li><code>类的私有方法</code><blockquote>
<p><strong>private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.</strong>private_methods。<br>实例<br>类的私有属性实例如下：</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">class JustCounter:</span><br><span class="line">    __secretCount = 0  # 私有变量</span><br><span class="line">    publicCount = 0    # 公开变量</span><br><span class="line">def count(self):</span><br><span class="line">        self.__secretCount += 1</span><br><span class="line">        self.publicCount += 1</span><br><span class="line">        print (self.__secretCount)</span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line">print (counter.publicCount)</span><br><span class="line">print (counter.__secretCount)  # 报错，实例不能访问私有变量</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 16, in &lt;module&gt;</span><br><span class="line">    print (counter.__secretCount)  # 报错，实例不能访问私有变量</span><br><span class="line">AttributeError: &apos;JustCounter&apos; object has no attribute &apos;__secretCount&apos;</span><br><span class="line">类的私有方法实例如下：</span><br><span class="line">#!/usr/bin/python3</span><br><span class="line">class Site:</span><br><span class="line">	def __init__(self, name, url):</span><br><span class="line">		self.name = name       # public</span><br><span class="line">		self.__url = url   # private</span><br><span class="line">def who(self):</span><br><span class="line">		print(&apos;name  : &apos;, self.name)</span><br><span class="line">		print(&apos;url : &apos;, self.__url)</span><br><span class="line">def __foo(self):          # 私有方法</span><br><span class="line">		print(&apos;这是私有方法&apos;)</span><br><span class="line">def foo(self):            # 公共方法</span><br><span class="line">		print(&apos;这是公共方法&apos;)</span><br><span class="line">		self.__foo()</span><br><span class="line">x = Site(&apos;百度&apos;, &apos;www.baidu.com&apos;)</span><br><span class="line">x.who()        # 正常输出</span><br><span class="line">x.foo()        # 正常输出</span><br><span class="line">x.__foo()      # 报错</span><br><span class="line">以上实例执行结果：</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>类的专有方法：</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__init__ : 构造函数，在生成对象时调用</span><br><span class="line">__del__ : 析构函数，释放对象时使用</span><br><span class="line">__repr__ : 打印，转换</span><br><span class="line">__setitem__ : 按照索引赋值</span><br><span class="line">__getitem__: 按照索引获取值</span><br><span class="line">__len__: 获得长度</span><br><span class="line">__cmp__: 比较运算</span><br><span class="line">__call__: 函数调用</span><br><span class="line">__add__: 加运算</span><br><span class="line">__sub__: 减运算</span><br><span class="line">__mul__: 乘运算</span><br><span class="line">__div__: 除运算</span><br><span class="line">__mod__: 求余运算</span><br><span class="line">__pow__: 平方</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><code>运算符重载</code><br>Python同样支持运算符重载，我么可以对类的专有方法进行重载，实例如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">class Vector:</span><br><span class="line">   def __init__(self, a, b):</span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line">def __str__(self):</span><br><span class="line">      return &apos;Vector (%d, %d)&apos; % (self.a, self.b)</span><br><span class="line">   </span><br><span class="line">   def __add__(self,other):</span><br><span class="line">      return Vector(self.a + other.a, self.b + other.b)</span><br><span class="line">v1 = Vector(2,10)</span><br><span class="line">v2 = Vector(5,-2)</span><br><span class="line">print (v1 + v2)</span><br><span class="line">以上代码执行结果如下所示:</span><br><span class="line">Vector(7,8)</span><br></pre></td></tr></table></figure>
<h2 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h2><p><strong>静态方法和类方法</strong></p>
<ol>
<li><code>类方法</code><br>是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了），能够通过实例对象和类对象去访问。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class people:</span><br><span class="line">    country = &apos;china&apos;</span><br><span class="line">#类方法，用classmethod来进行修饰</span><br><span class="line">    @classmethod</span><br><span class="line">    def getCountry(cls):</span><br><span class="line">        return cls.country</span><br><span class="line">p = people()</span><br><span class="line">print p.getCountry()    #可以用过实例对象引用</span><br><span class="line">print people.getCountry()    #可以通过类对象引用</span><br><span class="line">类方法还有一个用途就是可以对类属性进行修改：</span><br><span class="line">class people:</span><br><span class="line">    country = &apos;china&apos;</span><br><span class="line">#类方法，用classmethod来进行修饰</span><br><span class="line">    @classmethod</span><br><span class="line">    def getCountry(cls):</span><br><span class="line">        return cls.country</span><br><span class="line">@classmethod</span><br><span class="line">    def setCountry(cls,country):</span><br><span class="line">        cls.country = country</span><br><span class="line">p = people()</span><br><span class="line">print p.getCountry()    #可以用过实例对象引用</span><br><span class="line">print people.getCountry()    #可以通过类对象引用</span><br><span class="line">p.setCountry(&apos;japan&apos;)   </span><br><span class="line">print p.getCountry()   </span><br><span class="line">print people.getCountry()</span><br></pre></td></tr></table></figure>
<p>结果显示在用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变<br>2.<code>静态方法</code><br>需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class people:</span><br><span class="line">    country = &apos;china&apos;</span><br><span class="line">@staticmethod</span><br><span class="line">    #静态方法</span><br><span class="line">    def getCountry():</span><br><span class="line">        return people.country</span><br><span class="line">print people.getCountry()</span><br></pre></td></tr></table></figure>
<p><em>总结</em><br>从类方法和实例方法以及静态方法的定义形式就可以看出来，<strong>类方法的第一个参数是类对象cls</strong>，那么通过cls引用的必定是类对象的属性和方法；而<strong>实例方法的第一个参数是实例对象self</strong>，那么通过self引用的可能是类属性、也有可能是实例属性（这个需要具体分析），不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。静态方法中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类对象来引用。</p>
<h2 id="Python内置类属性"><a href="#Python内置类属性" class="headerlink" title="Python内置类属性"></a>Python内置类属性</h2><p><em>Python内置类属性</em><br><code>__dict__</code> : 类的属性（包含一个字典，由类的数据属性组成）<br><code>__doc__</code> :类的文档字符串<br><code>__name__</code>: 类名<br><code>__module__</code>: 类定义所在的模块（类的全名是<code>__main__.className</code>，如果类位于一个导入模块mymod中，那么<code>className.__module__</code>等于 mymod）<br><code>__bases__</code> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</p>
<h2 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h2><p>python类的体系中如果出现了继承,子类如果没有写自己的初始化方法,会自动继承第一个父类的方法,所以我们需要自己写子类的初始化:如果像下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Enter A&quot;)</span><br><span class="line">        print(&quot;Leave A&quot;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Enter B&quot;)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        print(&quot;Leave B&quot;)</span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Enter C&quot;)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        print(&quot;Leave C&quot;)</span><br><span class="line"></span><br><span class="line">class D(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Enter D&quot;)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        print(&quot;Leave D&quot;)</span><br><span class="line"></span><br><span class="line">class E(B, C, D):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Enter E&quot;)</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        C.__init__(self)</span><br><span class="line">        D.__init__(self)</span><br><span class="line">        print(&quot;Leave E&quot;)</span><br><span class="line">s=E()</span><br></pre></td></tr></table></figure>
<p>会造成公共父类A被调用多次.</p>
<p>正确的办法是使用super,它会把当前的类返回一个父类的对象,注意你在体系中使用了super那么所有的地方都要使用super,否则可能造成父类多次被调用或者不能调用所有的父类方法(这是由super的机制造成的,具体实现不懂),super保证所有父类只会执行一次，而且修改代码时也很方便:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class A(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;Enter A&apos;)</span><br><span class="line">        self.__test = 0</span><br><span class="line">class C(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;Enter C&apos;)</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.__test2 = 3</span><br><span class="line">class D(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(&apos;enter D&apos;)</span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;Enter B&apos;)</span><br><span class="line">        super().__init__()</span><br><span class="line">    def set(self):</span><br><span class="line">        self.__test = 2</span><br><span class="line">    def display(self):</span><br><span class="line">        print(dir(self))</span><br><span class="line">class E(C,D):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;Enter E&apos;)</span><br><span class="line">        super().__init__();</span><br></pre></td></tr></table></figure>
<h2 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a>isinstance</h2><p><em>语法：</em><br>isinstance（object，type）</p>
<p>作用：来判断一个对象是否是一个已知的类型。<br>其第一个参数（object）为对象，第二个参数（type）为类型名(int…)或类型名的一个列表((int,list,float)是一个列表)。其返回值为布尔型（True or flase）。<br>若对象的类型与参数二的类型相同则返回True。若参数二为一个元组，则若对象类型与元组中类型名之一相同即返回True。<br>下面是两个例子：<br>例一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 4</span><br><span class="line">&gt;&gt;&gt; isinstance (a,int)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance (a,str)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance (a,(str,int,list))</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>例二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &quot;b&quot;</span><br><span class="line">&gt;&gt;&gt; isinstance(a,str)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(a,int)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(a,(int,list,float))</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(a,(int,list,float,str))</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p><strong>一、isinstance()</strong><br>在Python中可以使用type()与isinstance()这两个函数判断对象类型，而isinstance()函数的使用上比type更加方便。<br>复制代码 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line"> </span><br><span class="line">a = 10</span><br><span class="line"> </span><br><span class="line">def b():</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">print isinstance(a,(int,str))</span><br><span class="line">print isinstance(a,(float,str))</span><br><span class="line">print isinstance(b,(str,int))</span><br><span class="line"> </span><br><span class="line">class c:</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">obj = c()</span><br><span class="line"> </span><br><span class="line">print isinstance(obj,(c,int))</span><br></pre></td></tr></table></figure>
<p>执行结果：<br>复制代码 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line"> False</span><br><span class="line"> False</span><br><span class="line"> True</span><br></pre></td></tr></table></figure>
<p> <strong>二、isinstance 和 type的区别</strong><br><em>isinstance 和 type的区别在于：</em><br>复制代码 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">     pass</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">     pass</span><br><span class="line"></span><br><span class="line">isinstance(A(), A)  # returns True</span><br><span class="line"> type(A()) == A      # returns True</span><br><span class="line"> isinstance(B(), A)    # returns True</span><br><span class="line"> type(B()) == A        # returns False</span><br></pre></td></tr></table></figure>
<p>区别就是 对于subclass之类的 type就不行了，所以,强烈建议不要使用type判断对象类型。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型”。<br>所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态<br><strong>Python伪代码实现Java或C#的多态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  class F1:</span><br><span class="line">      pass</span><br><span class="line"></span><br><span class="line">class S1(F1):</span><br><span class="line">      def show(self):</span><br><span class="line">          print &apos;S1.show&apos;</span><br><span class="line"></span><br><span class="line">class S2(F1):</span><br><span class="line">      def show(self):</span><br><span class="line">          print &apos;S2.show&apos;</span><br></pre></td></tr></table></figure>
<p>由于在Java或C#中定义函数参数时，必须指定参数的类型<br>为了让Func函数既可以执行S1对象的show方法，又可以执行S2对象的show方法，所以，定义了一个S1和S2类的父类<br>而实际传入的参数是：S1对象和S2对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def Func(F1 obj):</span><br><span class="line">      &quot;&quot;&quot;Func函数需要接收一个F1类型或者F1子类的类型&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">print obj.show()</span><br><span class="line"></span><br><span class="line">s1_obj = S1()</span><br><span class="line">  Func(s1_obj) # 在Func函数中传入S1类的对象 s1_obj，执行 S1 的show方法，结果：S1.show</span><br><span class="line"></span><br><span class="line">s2_obj = S2()</span><br><span class="line">  Func(s2_obj) # 在Func函数中传入Ss类的对象 ss_obj，执行 Ss 的show方法，结果：S2.show</span><br></pre></td></tr></table></figure>
<p><strong>Python “鸭子类型”</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  class F1:</span><br><span class="line">      pass</span><br><span class="line"></span><br><span class="line">class S1(F1):</span><br><span class="line"></span><br><span class="line">def show(self):</span><br><span class="line">          print &apos;S1.show&apos;</span><br><span class="line"></span><br><span class="line">class S2(F1):</span><br><span class="line"></span><br><span class="line">def show(self):</span><br><span class="line">          print &apos;S2.show&apos;</span><br><span class="line"></span><br><span class="line">def Func(obj):</span><br><span class="line">      print obj.show()</span><br><span class="line"></span><br><span class="line">s1_obj = S1()</span><br><span class="line">  Func(s1_obj) </span><br><span class="line"></span><br><span class="line">s2_obj = S2()</span><br><span class="line">  Func(s2_obj)</span><br></pre></td></tr></table></figure>
<h1 id="File-文件-方法"><a href="#File-文件-方法" class="headerlink" title="File(文件) 方法"></a>File(文件) 方法</h1><p>file 对象使用 open 函数来创建：<br><strong>open函数</strong>，该函数用于文件处理:<br>操作文件时，一般需要经历如下步骤：<br>打开文件<br>操作文件<br><strong>一、打开文件</strong><br><code>文件句柄 = open(&#39;文件路径&#39;, &#39;模式&#39;)</code><br>打开文件时，需要指定文件路径和以何等方式打开文件，打开后，即可获取该文件句柄，日后通过此文件句柄对该文件操作。<br>打开文件的模式有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">r ，只读模式【默认】</span><br><span class="line">w，只写模式【不可读；不存在则创建；存在则清空内容；】</span><br><span class="line">x， 只写模式【不可读；不存在则创建，存在则报错】</span><br><span class="line">a， 追加模式【可读；   不存在则创建；存在则只追加内容；】</span><br><span class="line">&quot;+&quot; 表示可以同时读写某个文件</span><br><span class="line">r+， 读写【可读，可写】</span><br><span class="line">w+，写读【可读，可写】</span><br><span class="line">x+ ，写读【可读，可写】</span><br><span class="line">a+， 写读【可读，可写】</span><br><span class="line">&quot;b&quot;表示以字节的方式操作</span><br><span class="line">rb  或 r+b</span><br><span class="line">wb 或 w+b</span><br><span class="line">xb 或 w+b</span><br><span class="line">ab 或 a+b</span><br></pre></td></tr></table></figure>
<p> 注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型<br><strong>二、操作文件</strong><br>下表列出了 file 对象常用的函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">file.close()关闭文件。关闭后文件不能再进行读写操作。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">file.flush()刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">file.fileno()返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">file.isatty()如果文件连接到一个终端设备返回 True，否则返回 False。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">file.next()返回文件下一行。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">file.read([size])从文件读取指定的字节数，如果未给定或为负则读取所有。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">file.readline([size])读取整行，包括 “\n” 字符。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">file.readlines([sizeint])读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">file.seek(offset[, whence])设置文件当前位置</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">file.tell()返回文件当前位置。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">file.truncate([size])截取文件，截取的字节通过size指定，默认为当前文件位置。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">file.write(str)将字符串写入文件，没有返回值。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">file.writelines(sequence)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td>
</tr>
</tbody>
</table>
<p><strong>三、管理上下文</strong><br>为了避免打开文件后忘记关闭，可以通过管理上下文，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;log&apos;,&apos;r&apos;) as f:</span><br><span class="line">        </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如此方式，当with代码块执行完毕时，内部会自动关闭并释放文件资源。</p>
<p>在Python 2.7 及以后，with又支持同时对多个文件的上下文进行管理，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;log1&apos;) as obj1, open(&apos;log2&apos;) as obj2:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h1 id="OS文件-目录方法"><a href="#OS文件-目录方法" class="headerlink" title="OS文件/目录方法"></a>OS文件/目录方法</h1><p>os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">os.access(path, mode)检验权限模式</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">os.chdir(path)改变当前工作目录</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">os.chflags(path, flags)设置路径的标记为数字标记。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">os.chmod(path, mode)更改权限</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">os.chown(path, uid, gid)更改文件所有者</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">os.chroot(path)改变当前进程的根目录</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">os.close(fd)关闭文件描述符 fd</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">os.closerange(fd_low, fd_high)关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">os.dup(fd)复制文件描述符 fd</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">os.dup2(fd, fd2)将一个文件描述符 fd 复制到另一个 fd2</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">os.fchdir(fd)通过文件描述符改变当前工作目录</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">os.fchmod(fd, mode)改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">os.fchown(fd, uid, gid)修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left">os.fdatasync(fd)强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left">os.fdopen(fd[, mode[, bufsize]])通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left">os.fpathconf(fd, name)返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left">os.fstat(fd)返回文件描述符fd的状态，像stat()。</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left">os.fstatvfs(fd)返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left">os.fsync(fd)强制将文件描述符为fd的文件写入硬盘。</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left">os.ftruncate(fd, length)裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left">os.getcwd()返回当前工作目录</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left">os.getcwdu()返回一个当前工作目录的Unicode对象</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left">os.isatty(fd)如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left">os.lchflags(path, flags)设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left">os.lchmod(path, mode)修改连接文件权限</td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left">os.lchown(path, uid, gid)更改文件所有者，类似 chown，但是不追踪链接。</td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left">os.link(src, dst)创建硬链接，名为参数 dst，指向参数 src</td>
</tr>
<tr>
<td style="text-align:left">28</td>
<td style="text-align:left">os.listdir(path)返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
</tr>
<tr>
<td style="text-align:left">29</td>
<td style="text-align:left">os.lseek(fd, pos, how)设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left">os.lstat(path)像stat(),但是没有软链接</td>
</tr>
<tr>
<td style="text-align:left">31</td>
<td style="text-align:left">os.major(device)从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
</tr>
<tr>
<td style="text-align:left">32</td>
<td style="text-align:left">os.makedev(major, minor)以major和minor设备号组成一个原始设备号</td>
</tr>
<tr>
<td style="text-align:left">33</td>
<td style="text-align:left">os.makedirs(path[, mode])递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
</tr>
<tr>
<td style="text-align:left">34</td>
<td style="text-align:left">os.minor(device)从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
</tr>
<tr>
<td style="text-align:left">35</td>
<td style="text-align:left">os.mkdir(path[, mode])以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
</tr>
<tr>
<td style="text-align:left">36</td>
<td style="text-align:left">os.mkfifo(path[, mode])创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
</tr>
<tr>
<td style="text-align:left">37</td>
<td style="text-align:left">os.mknod(filename[, mode=0600, device])创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
</tr>
<tr>
<td style="text-align:left">38</td>
<td style="text-align:left">os.open(file, flags[, mode])打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr>
<td style="text-align:left">39</td>
<td style="text-align:left">os.openpty()打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
</tr>
<tr>
<td style="text-align:left">40</td>
<td style="text-align:left">os.pathconf(path, name)返回相关文件的系统配置信息。</td>
</tr>
<tr>
<td style="text-align:left">41</td>
<td style="text-align:left">os.pipe()创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td>
</tr>
<tr>
<td style="text-align:left">42</td>
<td style="text-align:left">os.popen(command[, mode[, bufsize]])从一个 command 打开一个管道</td>
</tr>
<tr>
<td style="text-align:left">43</td>
<td style="text-align:left">os.read(fd, n)从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
</tr>
<tr>
<td style="text-align:left">44</td>
<td style="text-align:left">os.readlink(path)返回软链接所指向的文件</td>
</tr>
<tr>
<td style="text-align:left">45</td>
<td style="text-align:left">os.remove(path)删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
</tr>
<tr>
<td style="text-align:left">46</td>
<td style="text-align:left">os.removedirs(path)递归删除目录。</td>
</tr>
<tr>
<td style="text-align:left">47</td>
<td style="text-align:left">os.rename(src, dst)重命名文件或目录，从 src 到 dst</td>
</tr>
<tr>
<td style="text-align:left">48</td>
<td style="text-align:left">os.renames(old, new)递归地对目录进行更名，也可以对文件进行更名。</td>
</tr>
<tr>
<td style="text-align:left">49</td>
<td style="text-align:left">os.rmdir(path)删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
</tr>
<tr>
<td style="text-align:left">50</td>
<td style="text-align:left">os.stat(path)获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td>
</tr>
<tr>
<td style="text-align:left">51</td>
<td style="text-align:left">os.stat_float_times([newvalue])决定stat_result是否以float对象显示时间戳</td>
</tr>
<tr>
<td style="text-align:left">52</td>
<td style="text-align:left">os.statvfs(path)获取指定路径的文件系统统计信息</td>
</tr>
<tr>
<td style="text-align:left">53</td>
<td style="text-align:left">os.symlink(src, dst)创建一个软链接</td>
</tr>
<tr>
<td style="text-align:left">54</td>
<td style="text-align:left">os.tcgetpgrp(fd)返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td>
</tr>
<tr>
<td style="text-align:left">55</td>
<td style="text-align:left">os.tcsetpgrp(fd, pg)设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td>
</tr>
<tr>
<td style="text-align:left">56</td>
<td style="text-align:left">os.tempnam([dir[, prefix]])返回唯一的路径名用于创建临时文件。</td>
</tr>
<tr>
<td style="text-align:left">57</td>
<td style="text-align:left">os.tmpfile()返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td>
</tr>
<tr>
<td style="text-align:left">58</td>
<td style="text-align:left">os.tmpnam()为创建一个临时文件返回一个唯一的路径</td>
</tr>
<tr>
<td style="text-align:left">59</td>
<td style="text-align:left">os.ttyname(fd)返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td>
</tr>
<tr>
<td style="text-align:left">60</td>
<td style="text-align:left">os.unlink(path)删除文件路径</td>
</tr>
<tr>
<td style="text-align:left">61</td>
<td style="text-align:left">os.utime(path, times)返回指定的path文件的访问和修改的时间。</td>
</tr>
<tr>
<td style="text-align:left">62</td>
<td style="text-align:left">os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])输出在文件夹中的文件名通过在树中游走，向上或者向下。</td>
</tr>
<tr>
<td style="text-align:left">63</td>
<td style="text-align:left">os.write(fd, str)写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td>
</tr>
</tbody>
</table>
<h1 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h1><p>作为Python初学者，在刚学习Python编程时，经常会看到一些报错信息，在前面我们没有提及，这章节我们会专门介绍。<br>Python有两种错误很容易辨认：语法错误和异常。<br><strong>语法错误</strong><br>Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; while True print(&apos;Hello world&apos;)</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">    while True print(&apos;Hello world&apos;)</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<p>这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号（:）。<br>语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。</p>
<p><strong>异常</strong><br>即便Python程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。<br>大多数的异常都不会被程序处理，都以错误信息的形式展现在这里:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 * (1/0)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">&gt;&gt;&gt; 4 + spam*3</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">NameError: name &apos;spam&apos; is not defined</span><br><span class="line">&gt;&gt;&gt; &apos;2&apos; + 2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly</span><br></pre></td></tr></table></figure>
<p>异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有<code>ZeroDivisionError</code>，<code>NameError</code>和 <code>TypeError</code>。<br>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。<br><strong>异常处理</strong><br>以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 <code>KeyboardInterrupt</code> 异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">        try:</span><br><span class="line">            x = int(input(&quot;Please enter a number: &quot;))</span><br><span class="line">            break</span><br><span class="line">        except ValueError:</span><br><span class="line">            print(&quot;Oops!  That was no valid number.  Try again   &quot;)</span><br></pre></td></tr></table></figure>
<p>try语句按照如下方式工作；<br>• 首先，执行try子句（在关键字try和关键字except之间的语句）<br>• 如果没有异常发生，忽略except子句，try子句执行后结束。<br>• 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。<br>• 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。<br>一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。<br>处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。<br>一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">except (RuntimeError, TypeError, NameError):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">try:</span><br><span class="line">    f = open(&apos;myfile.txt&apos;)</span><br><span class="line">    s = f.readline()</span><br><span class="line">    i = int(s.strip())</span><br><span class="line">except OSError as err:</span><br><span class="line">    print(&quot;OS error: &#123;0&#125;&quot;.format(err))</span><br><span class="line">except ValueError:</span><br><span class="line">    print(&quot;Could not convert data to an integer.&quot;)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])</span><br><span class="line">    raise</span><br><span class="line">try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。例如:</span><br><span class="line">for arg in sys.argv[1:]:</span><br><span class="line">    try:</span><br><span class="line">        f = open(arg, &apos;r&apos;)</span><br><span class="line">    except IOError:</span><br><span class="line">        print(&apos;cannot open&apos;, arg)</span><br><span class="line">    else:</span><br><span class="line">        print(arg, &apos;has&apos;, len(f.readlines()), &apos;lines&apos;)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>
<p>使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。<br>异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def this_fails():</span><br><span class="line">        x = 1/0</span><br><span class="line">   </span><br><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        this_fails()</span><br><span class="line">    except ZeroDivisionError as err:</span><br><span class="line">        print(&apos;Handling run-time error:&apos;, err)</span><br><span class="line">   </span><br><span class="line">Handling run-time error: int division or modulo by zero</span><br></pre></td></tr></table></figure>
<p><strong>抛出异常</strong><br>Python 使用 raise 语句抛出一个指定的异常。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise NameError(&apos;HiThere&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure>
<p><code>raise</code> 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。<br>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        raise NameError(&apos;HiThere&apos;)</span><br><span class="line">    except NameError:</span><br><span class="line">        print(&apos;An exception flew by!&apos;)</span><br><span class="line">        raise</span><br><span class="line">   </span><br><span class="line">An exception flew by!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure>
<p><strong>用户自定义异常</strong><br>你可以通过创建一个新的exception类来拥有自己的异常。异常应该继承自 Exception 类，或者直接继承，或者间接继承，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyError(Exception):</span><br><span class="line">        def __init__(self, value):</span><br><span class="line">            self.value = value</span><br><span class="line">        def __str__(self):</span><br><span class="line">            return repr(self.value)</span><br><span class="line">   </span><br><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        raise MyError(2*2)</span><br><span class="line">    except MyError as e:</span><br><span class="line">        print(&apos;My exception occurred, value:&apos;, e.value)</span><br><span class="line">   </span><br><span class="line">My exception occurred, value: 4</span><br><span class="line">&gt;&gt;&gt; raise MyError(&apos;oops!&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">__main__.MyError: &apos;oops!&apos;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，类 <code>Exception</code>默认的 <code>__init__()</code>被覆盖。<br>异常的类可以像其他的类一样做任何事情，但是通常都会比较简单，只提供一些错误相关的属性，并且允许处理异常的代码方便的获取这些信息。<br>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Error(Exception):</span><br><span class="line">    &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line">class InputError(Error):</span><br><span class="line">    &quot;&quot;&quot;Exception raised for errors in the input.</span><br><span class="line">Attributes:</span><br><span class="line">        expression -- input expression in which the error occurred</span><br><span class="line">        message -- explanation of the error</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">def __init__(self, expression, message):</span><br><span class="line">        self.expression = expression</span><br><span class="line">        self.message = message</span><br><span class="line">class TransitionError(Error):</span><br><span class="line">    &quot;&quot;&quot;Raised when an operation attempts a state transition that&apos;s not</span><br><span class="line">    allowed.</span><br><span class="line">Attributes:</span><br><span class="line">        previous -- state at beginning of transition</span><br><span class="line">        next -- attempted new state</span><br><span class="line">        message -- explanation of why the specific transition is not allowed</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">def __init__(self, previous, next, message):</span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.next = next</span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure>
<p>大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。</p>
<p><strong>定义清理行为</strong><br>try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        raise KeyboardInterrupt</span><br><span class="line">	finally:</span><br><span class="line">        print(&apos;Goodbye, world!&apos;)</span><br><span class="line">   </span><br><span class="line">Goodbye, world!</span><br><span class="line">KeyboardInterrupt</span><br></pre></td></tr></table></figure>
<p>以上例子不管try子句里面有没有发生异常，finally子句都会执行。<br>如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。<br>下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally 子句）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def divide(x, y):</span><br><span class="line">        try:</span><br><span class="line">            result = x / y</span><br><span class="line">        except ZeroDivisionError:</span><br><span class="line">            print(&quot;division by zero!&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;result is&quot;, result)</span><br><span class="line">        finally:</span><br><span class="line">            print(&quot;executing finally clause&quot;)</span><br><span class="line">   </span><br><span class="line">&gt;&gt;&gt; divide(2, 1)</span><br><span class="line">result is 2.0</span><br><span class="line">executing finally clause</span><br><span class="line">&gt;&gt;&gt; divide(2, 0)</span><br><span class="line">division by zero!</span><br><span class="line">executing finally clause</span><br><span class="line">&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)</span><br><span class="line">executing finally clause</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in divide</span><br><span class="line">TypeError: unsupported operand type(s) for /: &apos;str&apos; and &apos;str&apos;</span><br></pre></td></tr></table></figure>
<p><strong>预定义的清理行为</strong><br>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。<br>这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for line in open(&quot;myfile.txt&quot;):</span><br><span class="line">    print(line, end=&quot;&quot;)</span><br></pre></td></tr></table></figure>
<p>以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。<br><code>关键词 with</code>语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;myfile.txt&quot;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        print(line, end=&quot;&quot;)</span><br></pre></td></tr></table></figure>
<p>以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。<br>异常的类可以像其他的类一样做任何事情，但是通常都会比较简单，只提供一些错误相关的属性，并且允许处理异常的代码方便的获取这些信息。</p>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块，用一坨代码实现了某个功能的代码集合。<br>类似于函数式编程和面向过程编程，函数式编程则完成一个功能，其他代码用来调用即可，提供了代码的重用性和代码间的耦合。而对于一个复杂的功能来，可能需要多个函数才能完成（函数又可以在不同的.py文件中），n个 .py 文件组成的代码集合就称为模块。</p>
<p>如：os 是系统相关的模块；file是文件操作相关的模块<br>模块分为三种：</p>
<ol>
<li>自定义模块</li>
<li>第三方模块</li>
<li>内置模块<h2 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h2>1、<strong>定义模块</strong><br>情景一：<figure class="image-box">
                <a rel="与Python进阶" href="./img/6.png" title="undefined" data-fancybox="images"><img src="./img/6.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
情景二：<figure class="image-box">
                <a rel="与Python进阶" href="./img/7.png" title="undefined" data-fancybox="images"><img src="./img/7.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
情景三：<figure class="image-box">
                <a rel="与Python进阶" href="./img/8.png" title="undefined" data-fancybox="images"><img src="./img/8.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
2、<strong>导入模块</strong><br>Python之所以应用越来越广泛，在一定程度上也依赖于其为程序员提供了大量的模块以供使用，如果想要使用模块，则需要导入。导入模块有一下几种方法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import module</span><br><span class="line">from module.xx.xx import xx</span><br><span class="line">from module.xx.xx import xx as rename </span><br><span class="line">from module.xx.xx import *</span><br></pre></td></tr></table></figure>
<p>导入模块其实就是告诉Python解释器去解释那个py文件</p>
<blockquote>
<p>导入一个py文件，解释器解释该py文件<br>导入一个包，解释器解释该包下的 <strong>init</strong>.py 文件 【py2.7】</p>
</blockquote>
<p>那么问题来了，导入模块时是根据那个路径作为基准来进行的呢？即：sys.path<br><figure class="image-box">
                <a rel="与Python进阶" href="./img/5.png" title="undefined" data-fancybox="images"><img src="./img/5.png" alt="" title="" class=""></a>
                <p></p>
            </figure></p>
<h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><p>用于提供对Python解释器相关的操作：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sys.argv</td>
<td style="text-align:left">命令行参数List，第一个元素是程序本身路径</td>
</tr>
<tr>
<td style="text-align:left">sys.exit(n)</td>
<td style="text-align:left">退出程序，正常退出时exit(0)</td>
</tr>
<tr>
<td style="text-align:left">sys.version</td>
<td style="text-align:left">获取Python解释程序的版本信息</td>
</tr>
<tr>
<td style="text-align:left">sys.maxint</td>
<td style="text-align:left">最大的Int值</td>
</tr>
<tr>
<td style="text-align:left">sys.path</td>
<td style="text-align:left">返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</td>
</tr>
<tr>
<td style="text-align:left">sys.platform</td>
<td style="text-align:left">返回操作系统平台名称</td>
</tr>
<tr>
<td style="text-align:left">sys.stdin</td>
<td style="text-align:left">输入相关</td>
</tr>
<tr>
<td style="text-align:left">sys.stdout</td>
<td style="text-align:left">输出相关</td>
</tr>
<tr>
<td style="text-align:left">sys.stderror</td>
<td style="text-align:left">错误相关</td>
</tr>
</tbody>
</table>
<h2 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h2><p>用于加密相关的操作，代替了<code>md5模块</code>和<code>sha模块</code>，主要提供 <strong>SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5</strong> 算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"># ######## md5 ########</span><br><span class="line">hash = hashlib.md5()</span><br><span class="line"># help(hash.update)</span><br><span class="line">hash.update(bytes(&apos;admin&apos;, encoding=&apos;utf-8&apos;))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line">print(hash.digest())</span><br><span class="line"> </span><br><span class="line">######## sha1 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha1()</span><br><span class="line">hash.update(bytes(&apos;admin&apos;, encoding=&apos;utf-8&apos;))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha256 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha256()</span><br><span class="line">hash.update(bytes(&apos;admin&apos;, encoding=&apos;utf-8&apos;))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha384 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha384()</span><br><span class="line">hash.update(bytes(&apos;admin&apos;, encoding=&apos;utf-8&apos;))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha512 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha512()</span><br><span class="line">hash.update(bytes(&apos;admin&apos;, encoding=&apos;utf-8&apos;))</span><br><span class="line">print(hash.hexdigest())</span><br></pre></td></tr></table></figure>
<p>以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"># ######## md5 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.md5(bytes(&apos;898oaFs09f&apos;,encoding=&quot;utf-8&quot;))</span><br><span class="line">hash.update(bytes(&apos;admin&apos;,encoding=&quot;utf-8&quot;))</span><br><span class="line">print(hash.hexdigest())</span><br></pre></td></tr></table></figure>
<p>python内置还有一个 <code>hmac</code> 模块，它内部对我们创建 key 和 内容 进行进一步的处理然后再加密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import hmac</span><br><span class="line"> </span><br><span class="line">h = hmac.new(bytes(&apos;898oaFs09f&apos;,encoding=&quot;utf-8&quot;))</span><br><span class="line">h.update(bytes(&apos;admin&apos;,encoding=&quot;utf-8&quot;))</span><br><span class="line">print(h.hexdigest())</span><br></pre></td></tr></table></figure>
<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>随机数的模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"> </span><br><span class="line">print(random.random())</span><br><span class="line">print(random.randint(1, 2))</span><br><span class="line">print(random.randrange(1, 10))</span><br></pre></td></tr></table></figure>
<p><em>随机验证码：</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">checkcode = &apos;&apos;</span><br><span class="line">for i in range(4):</span><br><span class="line">    current = random.randrange(0,4)</span><br><span class="line">    if current != i:</span><br><span class="line">        temp = chr(random.randint(65,90))</span><br><span class="line">    else:</span><br><span class="line">        temp = random.randint(0,9)</span><br><span class="line">    checkcode += str(temp)</span><br><span class="line">print checkcode</span><br></pre></td></tr></table></figure>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>Python中用于序列化的两个模块</p>
<p><strong>json</strong>     用于【字符串】和 【python基本数据类型】 间进行转换<br><strong>pickle</strong>   用于【python特有的类型】 和 【python基本数据类型】间进行转换<br>Json模块提供了四个功能：<code>dumps、dump、loads、load</code><br>pickle模块提供了四个功能：<code>dumps、dump、loads、load</code><br><figure class="image-box">
                <a rel="与Python进阶" href="./img/9.png" title="undefined" data-fancybox="images"><img src="./img/9.png" alt="" title="" class=""></a>
                <p></p>
            </figure></p>
<h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>Python标准库中提供了：urllib等模块以供Http请求，但是，它的 API 太渣了。它是为另一个时代、另一个互联网所创建的。它需要巨量的工作，甚至包括各种方法覆盖，来完成最简单的任务。<br><em>发送GET请求</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">f = urllib.request.urlopen(&apos;http://www.webxml.com.cn//webservices/qqOnlineWebService.asmx/qqCheckOnline?qqCode=424662508&apos;)</span><br><span class="line">result = f.read().decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure>
<p><em>发送携带参数的get请求</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">req = urllib.request.Request(&apos;http://www.example.com/&apos;)</span><br><span class="line">req.add_header(&apos;Referer&apos;, &apos;http://www.python.org/&apos;)</span><br><span class="line">r = urllib.request.urlopen(req)</span><br><span class="line"></span><br><span class="line">result = f.read().decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure>
<p><strong>Requests</strong> 是使用 Apache2 Licensed 许可证的 基于Python开发的HTTP 库，其在Python内置模块的基础上进行了高度的封装，从而使得Pythoner进行网络请求时，变得美好了许多，使用Requests可以轻而易举的完成浏览器可有的任何操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># 1、无参数实例</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line"> </span><br><span class="line">ret = requests.get(&apos;https://github.com/timeline.json&apos;)</span><br><span class="line"> </span><br><span class="line">print(ret.url)</span><br><span class="line">print(ret.text)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 2、有参数实例</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line"> </span><br><span class="line">payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line">ret = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)</span><br><span class="line"> </span><br><span class="line">print(ret.url)</span><br><span class="line">print(ret.text)</span><br><span class="line">复制代码</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line"># 1、基本POST实例</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line"> </span><br><span class="line">payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line">ret = requests.post(&quot;http://httpbin.org/post&quot;, data=payload)</span><br><span class="line"> </span><br><span class="line">print(ret.text)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 2、发送请求头和数据实例</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line"> </span><br><span class="line">url = &apos;https://api.github.com/some/endpoint&apos;</span><br><span class="line">payload = &#123;&apos;some&apos;: &apos;data&apos;&#125;</span><br><span class="line">headers = &#123;&apos;content-type&apos;: &apos;application/json&apos;&#125;</span><br><span class="line"> </span><br><span class="line">ret = requests.post(url, data=json.dumps(payload), headers=headers)</span><br><span class="line"> </span><br><span class="line">print(ret.text)</span><br><span class="line">print(ret.cookies)</span><br><span class="line"></span><br><span class="line">requests.get(url, params=None, **kwargs)</span><br><span class="line">requests.post(url, data=None, json=None, **kwargs)</span><br><span class="line">requests.put(url, data=None, **kwargs)</span><br><span class="line">requests.head(url, **kwargs)</span><br><span class="line">requests.delete(url, **kwargs)</span><br><span class="line">requests.patch(url, data=None, **kwargs)</span><br><span class="line">requests.options(url, **kwargs)</span><br><span class="line"> </span><br><span class="line"># 以上方法均是在此方法的基础上构建</span><br><span class="line">requests.request(method, url, **kwargs)</span><br></pre></td></tr></table></figure>
<h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><p>用于便捷记录日志且线程安全的模块<br><em>1、单文件日志</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(filename=&apos;log.log&apos;,</span><br><span class="line">                    format=&apos;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&apos;,</span><br><span class="line">                    datefmt=&apos;%Y-%m-%d %H:%M:%S %p&apos;,</span><br><span class="line">                    level=10)</span><br><span class="line">  </span><br><span class="line">logging.debug(&apos;debug&apos;)</span><br><span class="line">logging.info(&apos;info&apos;)</span><br><span class="line">logging.warning(&apos;warning&apos;)</span><br><span class="line">logging.error(&apos;error&apos;)</span><br><span class="line">logging.critical(&apos;critical&apos;)</span><br><span class="line">logging.log(10,&apos;log&apos;)</span><br></pre></td></tr></table></figure>
<p><em>日志等级：</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CRITICAL = 50</span><br><span class="line">FATAL = CRITICAL</span><br><span class="line">ERROR = 40</span><br><span class="line">WARNING = 30</span><br><span class="line">WARN = WARNING</span><br><span class="line">INFO = 20</span><br><span class="line">DEBUG = 10</span><br><span class="line">NOTSET = 0</span><br></pre></td></tr></table></figure>
<p>注：只有【当前写等级】大于【日志等级】时，日志文件才被记录。<br>日志记录格式：<br><figure class="image-box">
                <a rel="与Python进阶" href="./img/10.png" title="undefined" data-fancybox="images"><img src="./img/10.png" alt="" title="" class=""></a>
                <p></p>
            </figure></p>
<p><em>2、多文件日志</em></p>
<p>对于上述记录日志的功能，只能将日志记录在单文件中，如果想要设置多个日志文件，logging.basicConfig将无法完成，需要自定义文件和日志操作对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 定义文件</span><br><span class="line">file_1_1 = logging.FileHandler(&apos;l1_1.log&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">fmt = logging.Formatter(fmt=&quot;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&quot;)</span><br><span class="line">file_1_1.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line">file_1_2 = logging.FileHandler(&apos;l1_2.log&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">fmt = logging.Formatter()</span><br><span class="line">file_1_2.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line"># 定义日志</span><br><span class="line">logger1 = logging.Logger(&apos;s1&apos;, level=logging.ERROR)</span><br><span class="line">logger1.addHandler(file_1_1)</span><br><span class="line">logger1.addHandler(file_1_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 写日志</span><br><span class="line">logger1.critical(&apos;1111&apos;)</span><br><span class="line"></span><br><span class="line"># 定义文件</span><br><span class="line">file_2_1 = logging.FileHandler(&apos;l2_1.log&apos;, &apos;a&apos;)</span><br><span class="line">fmt = logging.Formatter()</span><br><span class="line">file_2_1.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line"># 定义日志</span><br><span class="line">logger2 = logging.Logger(&apos;s2&apos;, level=logging.INFO)</span><br><span class="line">logger2.addHandler(file_2_1)</span><br></pre></td></tr></table></figure>
<p>如上述创建的两个日志对象<br>当使用【logger1】写日志时，会将相应的内容写入 l1_1.log 和 l1_2.log 文件中<br>当使用【logger2】写日志时，会将相应的内容写入 l2_1.log 文件中</p>
<h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><p>时间相关的操作，时间有三种表示方式：</p>
<p>时间戳               1970年1月1日之后的秒，即：time.time()<br>格式化的字符串    2014-11-11 11:11，    即：time.strftime(‘%Y-%m-%d’)<br>结构化时间          元组包含了：年、日、星期等… time.struct_time    即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">time.localtime()</span><br><span class="line"></span><br><span class="line">print time.time()</span><br><span class="line">print time.mktime(time.localtime())</span><br><span class="line">   </span><br><span class="line">print time.gmtime()    #可加时间戳参数</span><br><span class="line">print time.localtime() #可加时间戳参数</span><br><span class="line">print time.strptime(&apos;2014-11-11&apos;, &apos;%Y-%m-%d&apos;)</span><br><span class="line">   </span><br><span class="line">print time.strftime(&apos;%Y-%m-%d&apos;) #默认当前时间</span><br><span class="line">print time.strftime(&apos;%Y-%m-%d&apos;,time.localtime()) #默认当前时间</span><br><span class="line">print time.asctime()</span><br><span class="line">print time.asctime(time.localtime())</span><br><span class="line">print time.ctime(time.time())</span><br><span class="line">   </span><br><span class="line">import datetime</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">datetime.date：表示日期的类。常用的属性有year, month, day</span><br><span class="line">datetime.time：表示时间的类。常用的属性有hour, minute, second, microsecond</span><br><span class="line">datetime.datetime：表示日期时间</span><br><span class="line">datetime.timedelta：表示时间间隔，即两个时间点之间的长度</span><br><span class="line">timedelta([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]])</span><br><span class="line">strftime(&quot;%Y-%m-%d&quot;)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">import datetime</span><br><span class="line">print datetime.datetime.now()</span><br><span class="line">print datetime.datetime.now() - datetime.timedelta(days=5)</span><br></pre></td></tr></table></figure>
        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-11-14T07:02:19.867Z" itemprop="dateUpdated">2018-11-14 15:02:19</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2017/03/15/与Python进阶/" target="_blank" rel="external">https://chengyuer.github.io/2017/03/15/与Python进阶/</a>
        
    </div>
    <footer>
        <a href="https://chengyuer.github.io">
            <img src="/img/pro.jpg" alt="煜立王冠">
            煜立王冠
        </a>
    </footer>
</blockquote>

        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://chengyuer.github.io/2017/03/15/与Python进阶/&title=《与Python进阶》 — 人生苦短，我用Python&pic=https://chengyuer.github.io/img/pro.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://chengyuer.github.io/2017/03/15/与Python进阶/&title=《与Python进阶》 — 人生苦短，我用Python&source=专注于Python各项应用与实践" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2017/05/09/select、poll、epoll的区别/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">select、poll、epoll的区别</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2017/03/12/拥抱Python/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">拥抱Python</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Pyhton中的函数"><span class="post-toc-number">1.</span> <span class="post-toc-text">Pyhton中的函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、背景"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">一、背景</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数的定义"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">函数的定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三、函数调用"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">三、函数调用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#四、参数传递"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">四、参数传递</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#五、参数"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">五、参数</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Python中的面向对象"><span class="post-toc-number">2.</span> <span class="post-toc-text">Python中的面向对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#浅析面向对象编程"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">浅析面向对象编程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类和对象"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">类和对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Python面向对象"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">Python面向对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#静态方法和类方法"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">静态方法和类方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Python内置类属性"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">Python内置类属性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Super"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">Super</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#isinstance"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">isinstance</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#多态"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">多态</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#File-文件-方法"><span class="post-toc-number">3.</span> <span class="post-toc-text">File(文件) 方法</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#OS文件-目录方法"><span class="post-toc-number">4.</span> <span class="post-toc-text">OS文件/目录方法</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#异常信息"><span class="post-toc-number">5.</span> <span class="post-toc-text">异常信息</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#模块"><span class="post-toc-number">6.</span> <span class="post-toc-text">模块</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#自定义模块"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">自定义模块</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#sys"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">sys</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#hashlib"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">hashlib</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#random"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">random</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#序列化"><span class="post-toc-number">6.5.</span> <span class="post-toc-text">序列化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#requests"><span class="post-toc-number">6.6.</span> <span class="post-toc-text">requests</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#logging"><span class="post-toc-number">6.7.</span> <span class="post-toc-text">logging</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#time"><span class="post-toc-number">6.8.</span> <span class="post-toc-text">time</span></a></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </div></div></aside>
    
</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        觉得好你就扫个码
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/ma.png" alt="打赏二维码">
        </div>
        
    </div>
</div>

    

</div>

        <footer class="footer">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://github.com/chengyuer" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                煜立王冠 &copy; 2017 - 2019
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://chengyuer.github.io/2017/03/15/与Python进阶/&title=《与Python进阶》 — 人生苦短，我用Python&pic=https://chengyuer.github.io/img/pro.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://chengyuer.github.io/2017/03/15/与Python进阶/&title=《与Python进阶》 — 人生苦短，我用Python&source=专注于Python各项应用与实践" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLUlEQVR42u3aS27DMAwFwNz/0um2QGvnkVQLSB6vjKS1NF4w4uf1iq/3t+vnJ/ffTlZZfGFgYGzLeN9eV3/Tw1xttPr8X6gYGBgPYFxFsMn91XbvV7l65oc9Y2BgYAQhMtlEwsbAwMBYFXDzJXsHUAwMDIxJ6Mx5SfmsmjwvyMUxMDA2ZORV9/+//5P+BgYGxlaMd/GaHPjyMlx5VxgYGEcz8gCXH8h6LYHk8w+rYGBgHM1IHpoMSeSpadJsqMIwMDDOZuSNgaQ90AvEk+YEBgbGExh5wK3WvvLXUT0+jn43MDAwtmJUF8iPennbspe+YmBgPIeRbLHXHsiDdd42+IDEwMA4mjE5OPYOi2uLfRgYGGczekMPvYDbS1ajUI6BgXE0o1qg7x31qgnzqPyHgYHxAEa+/Cpwdbw1KrphYGAcx6j+26SstioERzMjGBgYRzCqAXTe/uw1Jwr1PAwMjOMYVUwvgE4OnYWRDgwMjKMZ1WR1Pi42SYzLuTgGBsYRjGrATYa3qse7/NUs+93AwMDYkHH/iChmV2N8azhs9CYwMDA2Z1TLZ9UUt7yt6gvCwMA4lPEuXqvaAKtKb6/kVwIDA2NzxqQ/2EtTewnz5GVhYGCcweglrn+R7ublv6hqiIGBcRxjEviSI115bCIO3BgYGBiTgYlVDdGkeYCBgYFRvZ80SquDaBgYGM9hTJoBeTCdtEuXldswMDA2ZEwGtvKZjmrAnYd4DAyMIxhf0OqTYXu9auAAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.3.2"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.3.2"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.3.2"></script>
<script type="text/javascript" src="/js/blog.js?v=1.3.2"></script>

<!-- third-party -->







<script type="text/javascript" src="/js/plugins/local_search.js?v=1.3.2"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>




    <script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = '别走 ！';
                clearTimeout(titleTime);
            } else {
                document.title = '(つェ⊂)咦!又好了!';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>





    
</body>
</html>
